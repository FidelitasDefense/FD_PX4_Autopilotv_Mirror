/****************************************************************************
 *
 *   Copyright (c) 2013-2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mc_att_control_main.cpp
 * Multicopter attitude controller.
 *
 * Publication for the desired attitude tracking:
 * Daniel Mellinger and Vijay Kumar. Minimum Snap Trajectory Generation and Control for Quadrotors.
 * Int. Conf. on Robotics and Automation, Shanghai, China, May 2011.
 *
 * @author Lorenz Meier		<lorenz@px4.io>
 * @author Anton Babushkin	<anton.babushkin@me.com>
 * @author Sander Smeets	<sander@droneslab.com>
 *
 * The controller has two loops: P loop for angular error and PD loop for angular rate error.
 * Desired rotation calculated keeping in mind that yaw response is normally slower than roll/pitch.
 * For small deviations controller rotates copter to have shortest path of thrust vector and independently rotates around yaw,
 * so actual rotation axis is not constant. For large deviations controller rotates copter around fixed axis.
 * These two approaches fused seamlessly with weight depending on angular error.
 * When thrust vector directed near-horizontally (e.g. roll ~= PI/2) yaw setpoint ignored because of singularity.
 * Controller doesn't use Euler angles for work, they generated only for more human-friendly control and logging.
 * If rotation matrix setpoint is invalid it will be generated from Euler angles for compatibility with old position controllers.
 */

#include <px4_config.h>
#include <px4_defines.h>
#include <px4_tasks.h>
#include <px4_posix.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <poll.h>
#include <drivers/drv_hrt.h>
#include <arch/board/board.h>
#include <uORB/uORB.h>
#include <uORB/topics/vehicle_attitude_setpoint.h>
#include <uORB/topics/voliro_thrust_setpoint.h>
#include <uORB/topics/manual_control_setpoint.h>
#include <uORB/topics/actuator_controls.h>
#include <uORB/topics/vehicle_rates_setpoint.h>
#include <uORB/topics/fw_virtual_rates_setpoint.h>
#include <uORB/topics/mc_virtual_rates_setpoint.h>
#include <uORB/topics/control_state.h>
#include <uORB/topics/vehicle_control_mode.h>
#include <uORB/topics/vehicle_status.h>
#include <uORB/topics/actuator_armed.h>
#include <uORB/topics/parameter_update.h>
#include <uORB/topics/multirotor_motor_limits.h>
#include <uORB/topics/mc_att_ctrl_status.h>
#include <uORB/topics/battery_status.h>
#include <systemlib/param/param.h>
#include <systemlib/err.h>
#include <systemlib/perf_counter.h>
#include <systemlib/systemlib.h>
#include <systemlib/circuit_breaker.h>
#include <lib/mathlib/mathlib.h>
#include <lib/geo/geo.h>
#include <lib/tailsitter_recovery/tailsitter_recovery.h>


/**
 * Multicopter attitude control app start / stop handling function
 *
 * @ingroup apps
 */
extern "C" __EXPORT int mc_att_control_main(int argc, char *argv[]);

#define YAW_DEADZONE	0.05f
#define MIN_TAKEOFF_THRUST    0.2f
#define RATES_I_LIMIT	0.3f
#define MANUAL_THROTTLE_MAX_MULTICOPTER	0.9f
#define ATTITUDE_TC_DEFAULT 0.2f

#define AXIS_INDEX_ROLL 0
#define AXIS_INDEX_PITCH 1
#define AXIS_INDEX_YAW 2
#define AXIS_COUNT 3

static constexpr float alpha_lookup1[19][21] = \
{
    {     -0.0053f,     -0.0036f,      0.0002f,     -0.0069f,      0.0279f,     -0.0100f,      0.0201f,      0.0196f,     -0.0002f,     -0.0063f,      0.0205f,      0.0004f,     -0.0015f,      0.0232f,     -0.0015f,      0.0352f,      0.0207f,      0.0049f,      0.0163f,      0.0053f,     -0.0053},
    {      0.2631f,      0.2748f,      0.3071f,      0.0943f,      0.0331f,      0.0787f,     -0.0152f,     -0.1676f,     -0.3332f,     -0.2462f,     -0.3046f,     -0.2462f,     -0.3187f,     -0.2126f,     -0.0139f,      0.1499f,      0.0111f,      0.0772f,      0.3044f,      0.2748f,      0.1838},
    {      0.8034f,      0.6409f,      0.4817f,      0.4488f,      0.0379f,      0.0367f,     -0.2456f,     -0.4983f,     -0.5564f,     -0.6299f,     -0.6432f,     -0.6491f,     -0.4973f,     -0.5165f,     -0.2287f,      0.0330f,      0.0152f,      0.4722f,      0.4706f,      0.6131f,      0.7623},
    {      0.9630f,      0.8066f,      0.7993f,      0.7053f,      0.2295f,      0.0506f,     -0.2949f,     -0.6813f,     -0.6803f,     -0.8948f,     -0.9309f,     -0.8993f,     -0.7727f,     -0.6934f,     -0.2598f,      0.0042f,      0.2270f,      0.7233f,      0.7965f,      0.8106f,      0.9626},
    {      1.3438f,      1.0575f,      0.8732f,      0.6593f,      0.2901f,     -0.0363f,     -0.1748f,     -0.5454f,     -0.8646f,     -1.0138f,     -1.2217f,     -1.0163f,     -0.8607f,     -0.5998f,     -0.1711f,     -0.0059f,      0.2485f,      0.6357f,      0.8789f,      1.0207f,      1.3538},
    {      1.3828f,      1.3478f,      0.9089f,      0.7364f,      0.3033f,      0.0505f,     -0.4998f,     -0.8031f,     -1.0689f,     -1.2325f,     -1.3641f,     -1.2364f,     -1.0770f,     -0.8023f,     -0.4628f,      0.0216f,      0.3229f,      0.7270f,      0.9044f,      1.3654f,      1.3835},
    {      1.3978f,      1.2763f,      1.3554f,      1.1195f,      0.9122f,      0.5475f,     -0.7487f,     -1.0357f,     -1.2517f,     -1.3460f,     -1.7094f,     -1.3516f,     -1.1982f,     -1.0579f,     -0.7953f,      0.5992f,      0.9734f,      1.1168f,      1.3581f,      1.2584f,      1.3797},
    {      1.3360f,      1.2474f,      1.4151f,      1.1701f,      1.0972f,      0.8628f,      3.1416f,     -1.2360f,     -1.3312f,     -1.2567f,     -1.4041f,     -1.3055f,     -1.3481f,     -1.2377f,      3.1416f,      0.6913f,      1.0972f,      1.1736f,      1.4582f,      1.2545f,      1.3368},
    {      1.5877f,      1.5063f,      1.4891f,      1.2631f,     -3.1416f,     -2.3614f,     -0.9000f,     -1.3025f,     -1.5679f,     -1.5614f,     -1.6160f,     -1.5707f,     -1.5784f,     -1.3687f,     -0.9000f,     -2.2783f,     -3.1416f,      1.3282f,      1.4876f,      1.5279f,      1.6169},
    {      1.5551f,      1.7396f,      1.6428f,      1.5747f,     -3.1416f,     -2.8933f,     -1.5834f,     -1.7089f,     -1.4859f,     -1.6245f,      3.1416f,     -1.5919f,     -1.4859f,     -1.6466f,     -1.5834f,     -2.8830f,     -3.1416f,      1.5548f,      1.6584f,      1.7453f,      1.5551},
    {      1.5526f,      1.5720f,      1.6109f,      1.5852f,      1.6795f,      2.7556f,     -2.1005f,     -1.6707f,     -1.6109f,     -1.6932f,      3.1416f,     -1.6932f,     -1.6109f,     -1.6707f,     -2.1005f,      2.6534f,      1.6795f,      1.5852f,      1.6109f,      1.5720f,      1.5526},
    {      1.5379f,      1.7927f,      2.0502f,      1.7504f,      2.3207f,     -2.9630f,     -1.7228f,     -1.5208f,     -1.8694f,     -1.8092f,      3.1416f,     -1.8004f,     -1.8258f,     -1.5208f,     -1.7228f,     -2.7276f,      2.3207f,      1.7504f,      2.0549f,      1.8347f,      1.5379},
    {      2.2310f,      1.9291f,      1.9266f,      2.0315f,      2.1382f,     -2.7982f,     -2.0611f,     -1.7487f,     -1.7711f,     -1.7821f,     -1.9938f,     -1.7809f,     -1.7450f,     -1.7774f,     -2.0512f,     -2.8284f,      2.1229f,      2.0565f,      1.9216f,      1.9305f,      2.2548},
    {      1.5120f,      1.8893f,      2.1172f,      2.0227f,      1.8015f,     -2.9038f,     -1.5527f,     -2.4484f,     -1.7442f,      3.1415f,      3.1416f,      3.1416f,     -1.8996f,     -2.4672f,     -1.5248f,     -2.9805f,      1.8647f,      1.9005f,      2.0945f,      1.8797f,      1.5120},
    {      2.1487f,      2.4080f,      2.1816f,      2.3923f,      2.5593f,     -2.2815f,     -2.6413f,     -2.2413f,     -2.1946f,     -1.9958f,      3.1408f,     -1.9572f,     -2.2051f,     -2.2239f,     -2.6800f,     -2.4760f,      2.5937f,      2.3410f,      2.1531f,      2.4041f,      2.1388},
    {      1.7687f,      2.2754f,      2.4771f,      2.6137f,      2.7125f,     -2.1355f,     -2.6567f,     -2.4682f,     -2.1327f,     -2.6329f,     -1.4750f,     -2.6112f,     -2.2029f,     -2.4868f,     -2.6600f,     -2.1355f,      2.6965f,      2.5707f,      2.5234f,      2.2657f,      1.8970},
    {      2.2800f,      2.1583f,      2.1762f,      2.7341f,      2.8632f,     -2.9416f,     -2.8547f,     -2.2174f,     -2.6649f,     -2.3977f,     -2.9353f,     -2.4348f,     -2.7272f,     -2.1463f,     -2.8710f,     -2.8737f,      2.8829f,      2.7059f,      2.1339f,      2.1638f,      2.2824},
    {      3.1384f,      2.8563f,      2.7773f,      2.7098f,      2.9271f,     -3.1193f,     -2.7124f,     -2.9963f,     -2.9117f,     -2.5916f,     -2.7795f,     -2.5783f,     -2.9083f,     -3.0131f,     -2.5729f,     -3.1241f,      2.7004f,      2.7048f,      2.8321f,      2.8643f,      3.1346},
    {     -3.1410f,     -3.1409f,     -3.1409f,     -3.1412f,     -3.1410f,     -3.1407f,     -3.1415f,     -3.1410f,     -3.1405f,     -3.1405f,     -3.1412f,     -3.1411f,     -3.1410f,     -3.1403f,     -3.1412f,     -3.1411f,     -3.1410f,     -3.1406f,     -3.1409f,     -3.1413f,     -3.1410},
};

static constexpr float alpha_lookup2[19][21] = \
{
    {     -0.0157f,     -0.0458f,      0.0019f,     -0.0469f,     -0.0602f,     -0.0178f,     -0.0903f,     -0.0458f,     -0.0117f,     -0.0881f,     -0.0691f,     -0.0232f,      0.0000f,     -0.0330f,      0.0113f,     -0.0241f,     -0.0300f,     -0.0634f,     -0.0692f,     -0.0328f,     -0.0157},
    {     -0.4184f,     -0.2446f,     -0.3113f,     -0.1723f,     -0.0886f,      0.0698f,      0.0840f,      0.1121f,      0.3605f,      0.2749f,      0.4256f,      0.2749f,      0.3078f,      0.0833f,      0.0725f,      0.1726f,     -0.0378f,     -0.1416f,     -0.3069f,     -0.2449f,     -0.4742},
    {     -0.5766f,     -0.6477f,     -0.5724f,     -0.3732f,     -0.0780f,      0.0284f,      0.1094f,      0.4239f,      0.4802f,      0.6155f,      0.7962f,      0.6044f,      0.5477f,      0.4747f,      0.1032f,      0.0257f,     -0.2127f,     -0.4021f,     -0.5736f,     -0.6342f,     -0.6107},
    {     -0.9488f,     -0.8271f,     -0.6569f,     -0.6442f,     -0.3463f,      0.0328f,      0.2808f,      0.7240f,      0.7825f,      0.8953f,      0.9383f,      0.8933f,      0.6783f,      0.7206f,      0.3100f,      0.0091f,     -0.3078f,     -0.6485f,     -0.6952f,     -0.8302f,     -0.9122},
    {     -1.3081f,     -1.0105f,     -0.8198f,     -0.7288f,     -0.2545f,     -0.0100f,      0.3820f,      0.5100f,      0.9905f,      1.0243f,      1.2628f,      1.0337f,      0.9624f,      0.5564f,      0.3661f,      0.0104f,     -0.3148f,     -0.7520f,     -0.8322f,     -1.0188f,     -1.3085},
    {     -1.2953f,     -1.2142f,     -0.9901f,     -0.7913f,     -0.4678f,     -0.0016f,      0.3604f,      0.7654f,      0.8676f,      1.2683f,      1.4248f,      1.2730f,      0.9167f,      0.7607f,      0.3956f,      0.0336f,     -0.4660f,     -0.7808f,     -0.9827f,     -1.2264f,     -1.3043},
    {     -1.6128f,     -1.3338f,     -1.2065f,     -1.0562f,     -0.9269f,     -0.0163f,      0.9600f,      1.0926f,      1.3897f,      1.2829f,      1.5990f,      1.3049f,      1.3614f,      1.0787f,      1.0282f,     -0.0029f,     -0.9144f,     -1.0441f,     -1.2565f,     -1.3307f,     -1.5822},
    {     -1.4634f,     -1.3012f,     -1.2809f,     -1.2552f,      3.1416f,      0.2444f,      1.1663f,      1.2198f,      1.4898f,      1.2646f,      1.2418f,      1.3048f,      1.4766f,      1.2384f,      1.1663f,      0.2173f,      3.1416f,     -1.2439f,     -1.2937f,     -1.2939f,     -1.4561},
    {     -1.5900f,     -1.3469f,     -1.5413f,     -1.3088f,     -0.9132f,     -0.3244f,     -3.1416f,      1.3312f,      1.4628f,      1.5514f,      1.5907f,      1.5389f,      1.4824f,      1.3617f,     -3.1416f,     -0.2960f,     -0.9132f,     -1.3474f,     -1.5549f,     -1.3224f,     -1.6137},
    {      3.1416f,     -1.6550f,     -1.6600f,     -1.4856f,     -1.5376f,     -2.8050f,     -3.1416f,      1.6573f,      1.4214f,      1.5643f,      1.6524f,      1.5543f,      1.4214f,      1.6320f,     -3.1416f,     -2.8257f,     -1.5376f,     -1.4665f,     -1.6598f,     -1.6438f,      3.1416},
    {      3.1416f,     -1.5720f,     -1.6109f,     -1.6309f,     -1.9507f,      2.8249f,      1.6384f,      1.5354f,      1.6109f,      1.5358f,      1.6554f,      1.5358f,      1.6109f,      1.5354f,      1.6384f,      2.6912f,     -1.9507f,     -1.6309f,     -1.6109f,     -1.5720f,      3.1416},
    {      3.1416f,     -1.6356f,     -2.0149f,     -1.5838f,     -1.7513f,      2.8480f,      2.4297f,      1.7889f,      1.8148f,      1.8496f,      1.6628f,      1.8650f,      1.7603f,      1.7889f,      2.4297f,      2.6926f,     -1.7513f,     -1.5838f,     -2.0225f,     -1.6953f,      3.1416},
    {     -1.9071f,     -1.7204f,     -2.0480f,     -1.6668f,     -1.7878f,     -2.5484f,      2.2980f,      2.2541f,      2.0185f,      2.1236f,      2.3398f,      2.0937f,      2.0268f,      2.1817f,      2.2329f,     -2.6458f,     -1.8021f,     -1.6372f,     -2.0486f,     -1.7228f,     -1.8876},
    {      3.1416f,      3.1408f,     -2.0566f,     -2.4404f,     -1.5095f,      2.9927f,      1.5486f,      1.9124f,      2.0688f,      1.8279f,      1.6755f,      1.8405f,      2.0227f,      1.9500f,      1.5340f,      3.0741f,     -1.4805f,     -2.4563f,     -2.0690f,      3.1413f,      3.1416},
    {      3.1408f,     -2.4429f,     -2.1886f,     -2.2195f,     -2.6400f,     -1.7855f,      2.4522f,      2.2234f,      2.2818f,      1.7180f,      2.0171f,      1.7463f,      2.2789f,      2.2137f,      2.4513f,     -1.9055f,     -2.6815f,     -2.2155f,     -2.1827f,     -2.4391f,      3.1409},
    {     -1.1495f,     -2.4156f,     -2.3451f,     -2.5260f,     -2.6655f,     -2.1555f,      2.6799f,      2.6475f,      2.3742f,      2.5902f,      1.9979f,      2.6230f,      2.3991f,      2.6324f,      2.6492f,     -2.1555f,     -2.6471f,     -2.5121f,     -2.3231f,     -2.4147f,     -1.1931},
    {     -2.9429f,     -2.6176f,     -2.7533f,     -3.0108f,     -2.8569f,     -3.0105f,      2.9544f,      2.8420f,      2.3294f,      2.1754f,      2.6285f,      2.1406f,      2.3691f,      2.8275f,      2.9321f,     -2.9325f,     -2.8856f,     -2.7335f,     -2.7281f,     -2.6132f,     -2.9462},
    {     -2.8123f,     -2.6504f,     -2.8489f,     -2.9572f,     -3.0013f,     -3.0523f,      2.8962f,      2.6865f,      2.7505f,      2.8892f,      3.1315f,      2.8283f,      2.7623f,      2.6772f,      2.9052f,     -3.0618f,     -3.1204f,     -2.9948f,     -2.9853f,     -2.6161f,     -2.8151},
    {     -3.1377f,     -3.1382f,     -3.1384f,     -3.1367f,     -3.1383f,     -3.1339f,     -3.1308f,     -3.1374f,     -3.1360f,     -3.1371f,     -3.1367f,     -3.1392f,     -3.1377f,     -3.1376f,     -3.1368f,     -3.1387f,     -3.1374f,     -3.1360f,     -3.1389f,     -3.1324f,     -3.1377},
};

static constexpr float alpha_lookup3[19][21] = \
{
    {      0.0038f,      0.0318f,      0.0030f,      0.0400f,      0.0664f,      0.0134f,      0.1041f,      0.0175f,      0.0214f,      0.0692f,      0.0439f,      0.0162f,     -0.0017f,     -0.0055f,     -0.0076f,      0.0420f,      0.0098f,      0.0729f,      0.0324f,      0.0154f,      0.0038},
    {     -0.1003f,     -0.3326f,     -0.2475f,     -0.3959f,     -0.3569f,     -0.3153f,     -0.1513f,     -0.0679f,     -0.1208f,      0.1180f,      0.0630f,      0.3509f,      0.2847f,      0.3809f,      0.3090f,      0.1991f,      0.2041f,      0.1065f,      0.0496f,     -0.1659f,     -0.0263},
    {     -0.2823f,     -0.4630f,     -0.5124f,     -0.5292f,     -0.6188f,     -0.5734f,     -0.3884f,     -0.4715f,     -0.0861f,      0.1416f,      0.1309f,      0.3862f,      0.5304f,      0.6036f,      0.6602f,      0.5864f,      0.2466f,      0.1889f,      0.0717f,     -0.0426f,     -0.2833},
    {     -0.3609f,     -0.5801f,     -0.8184f,     -0.7475f,     -0.8173f,     -0.8240f,     -0.5994f,     -0.5741f,     -0.1577f,      0.0249f,      0.3038f,      0.5517f,      0.7969f,      0.7315f,      0.8467f,      0.6667f,      0.6495f,      0.5398f,      0.1353f,     -0.2445f,     -0.2813},
    {     -0.2761f,     -0.8528f,     -1.0494f,     -1.1118f,     -1.1500f,     -0.8821f,     -0.6763f,     -0.1310f,     -0.1527f,      0.2212f,      0.3981f,      0.8525f,      0.8975f,      1.0713f,      1.0890f,      0.8694f,      0.6712f,      0.8263f,      0.0640f,     -0.0930f,     -0.2821},
    {     -0.7976f,     -0.9655f,     -1.1985f,     -1.4055f,     -1.2619f,     -1.1592f,     -1.0045f,     -0.6332f,      0.1079f,      0.0041f,      0.5429f,      0.9164f,      1.2020f,      1.3903f,      1.2946f,      1.0806f,      0.9720f,      0.5551f,      0.2350f,     -0.3204f,     -0.8516},
    {     -0.8618f,     -1.1930f,     -1.2698f,     -1.3985f,     -1.3046f,     -1.2229f,     -1.0895f,     -0.7287f,     -0.2090f,      0.8189f,      0.8034f,      1.1172f,      1.0122f,      1.3553f,      1.2648f,      1.3902f,      1.1633f,      0.9396f,      1.0532f,     -0.4447f,     -0.8863},
    {     -1.1757f,     -1.3804f,     -1.4249f,     -1.4551f,     -1.3349f,     -1.3419f,     -1.3100f,     -1.0591f,     -0.3330f,      1.2341f,      1.4073f,      1.3653f,      1.1792f,      1.4507f,      1.6834f,      1.4190f,      0.5569f,      1.2181f,      1.3243f,     -1.1066f,     -1.1657},
    {     -1.2563f,     -1.5933f,     -1.4609f,     -1.6474f,      3.1416f,     -1.6515f,     -1.3875f,     -1.2950f,     -1.0480f,      1.0548f,      1.3620f,      1.4711f,      1.5499f,      1.5885f,      1.4486f,      1.4990f,     -3.1416f,      1.3628f,      0.5766f,     -1.6636f,     -1.2001},
    {     -1.4816f,     -1.5700f,     -1.6740f,     -1.5914f,     -1.6447f,     -1.5240f,     -1.3655f,     -1.3602f,      3.1416f,      1.7398f,      1.4732f,      1.5965f,      1.5559f,      1.6715f,     -3.1416f,      1.4681f,      1.5222f,      1.7407f,      0.7050f,     -1.4899f,     -1.4816},
    {     -1.5385f,     -1.6022f,     -1.5717f,     -1.6291f,     -1.6117f,     -1.5654f,     -1.6315f,     -1.9092f,      3.1416f,     -3.1416f,      1.6754f,      1.5839f,      1.5717f,     -3.1416f,     -3.1416f,      1.5919f,      1.5755f,      1.6465f,     -3.1416f,      3.1416f,     -1.5385},
    {     -1.5371f,     -1.8904f,     -1.8688f,      3.1416f,      3.1416f,     -1.7196f,     -1.5330f,     -1.6285f,     -1.4594f,      1.9608f,      1.8777f,      1.7331f,      2.0255f,      1.6260f,      1.6317f,      1.8303f,      1.6832f,      2.0273f,      0.7569f,     -2.1808f,     -1.5371},
    {     -2.1565f,     -2.0141f,     -1.5772f,     -2.1156f,     -1.9814f,     -1.9347f,     -2.1676f,     -1.5484f,     -1.8392f,      2.0017f,      1.5092f,      1.4902f,      1.7455f,      1.8547f,      1.8891f,      1.8541f,      2.2242f,      2.3438f,      2.7845f,      3.0620f,     -2.1432},
    {     -1.5367f,     -1.6508f,     -1.7629f,     -1.9515f,     -2.2097f,     -1.9949f,     -2.3918f,     -2.0937f,     -2.7996f,      3.0738f,      2.4272f,      1.9693f,      1.8450f,      2.2935f,      2.0617f,      1.4213f,      2.3348f,      1.6611f,      2.7745f,     -1.8954f,     -1.5367},
    {     -2.0757f,     -2.1524f,     -2.0377f,     -2.1550f,     -1.8907f,     -2.5680f,     -2.3280f,     -2.3702f,     -2.9069f,      2.7368f,      2.3437f,      2.4391f,      1.8553f,      2.1697f,      2.0714f,      2.1966f,      2.1578f,      2.5354f,      2.8853f,     -2.1713f,     -2.0946},
    {     -2.6090f,     -2.2689f,     -2.3031f,     -2.0017f,     -2.2768f,      3.1416f,     -2.5479f,     -2.9144f,     -2.8285f,      2.7993f,      2.8663f,      2.1271f,      2.2380f,      1.8782f,      2.4104f,      2.0160f,      2.3378f,      2.6298f,      2.8980f,     -2.7218f,     -2.5551},
    {     -2.3484f,     -2.4206f,     -2.0089f,     -1.7129f,     -1.7892f,     -2.6182f,     -2.8452f,     -2.7220f,     -2.9930f,      2.9676f,      2.6700f,      2.7447f,      2.6702f,      2.0954f,      2.4936f,      2.7325f,      2.6116f,      2.8692f,      2.7780f,     -3.0160f,     -2.3514},
    {     -2.8316f,     -2.9020f,     -3.0058f,     -2.4735f,     -2.8893f,     -2.9460f,     -2.9417f,     -3.0558f,     -3.0161f,      3.0060f,      2.7154f,      2.8362f,      2.8494f,      3.1371f,      2.7482f,      2.8331f,      3.1278f,      2.6238f,     -2.9922f,     -3.0795f,     -2.8334},
    {     -3.1400f,     -3.1400f,     -3.1404f,     -3.1408f,     -3.1399f,     -3.1404f,     -3.1410f,     -3.1406f,     -3.1408f,     -3.1403f,     -3.1402f,     -3.1401f,     -3.1406f,     -3.1404f,     -3.1412f,     -3.1406f,     -3.1407f,     -3.1407f,     -3.1405f,     -3.1409f,     -3.1400},
};

static constexpr float alpha_lookup4[19][21] = \
{
    {     -0.0056f,     -0.0022f,      0.0050f,      0.0017f,     -0.0081f,      0.0032f,     -0.0406f,     -0.0485f,      0.0149f,     -0.0120f,     -0.0431f,     -0.0058f,     -0.0003f,     -0.0517f,      0.0038f,     -0.0118f,     -0.0347f,     -0.0096f,     -0.0458f,     -0.0209f,     -0.0056},
    {      0.1961f,      0.3481f,      0.2824f,      0.3488f,      0.3516f,      0.2446f,      0.2237f,      0.0853f,      0.0578f,     -0.1681f,     -0.1617f,     -0.3279f,     -0.2320f,     -0.3175f,     -0.3959f,     -0.3095f,     -0.1124f,      0.0023f,     -0.1018f,      0.1214f,      0.2365},
    {      0.1608f,      0.3996f,      0.5895f,      0.6226f,      0.8444f,      0.4830f,      0.4090f,      0.2940f,      0.0939f,     -0.0054f,     -0.2271f,     -0.4227f,     -0.5707f,     -0.3718f,     -0.5887f,     -0.4946f,     -0.4121f,     -0.3850f,     -0.0966f,      0.0979f,      0.1333},
    {      0.2904f,      0.6921f,      0.7193f,      0.7203f,      0.8080f,      0.6935f,      0.6648f,      0.5548f,      0.1107f,     -0.1101f,     -0.3523f,     -0.5630f,     -0.7249f,     -0.7242f,     -0.8012f,     -0.8341f,     -0.5543f,     -0.5599f,     -0.1136f,      0.1271f,      0.3648},
    {      0.2942f,      0.6761f,      0.9891f,      0.9446f,      1.0886f,      0.9916f,      0.6480f,      0.7163f,      0.1364f,     -0.3099f,     -0.3303f,     -0.8134f,     -0.9854f,     -1.1683f,     -1.1486f,     -0.9432f,     -0.6417f,     -0.2630f,     -0.0740f,      0.3972f,      0.2912},
    {      0.6171f,      0.8523f,      1.2058f,      1.3774f,      1.2691f,      1.0640f,      0.9086f,      0.4462f,      0.2423f,     -0.4397f,     -0.6685f,     -0.8263f,     -1.1234f,     -1.3090f,     -1.2475f,     -1.1232f,     -0.9144f,     -0.4156f,      0.1687f,      0.0998f,      0.6386},
    {      0.8739f,      1.1902f,      1.0463f,      1.3432f,      1.2596f,      1.0630f,      1.1647f,      0.9781f,      1.0984f,     -0.3929f,     -0.8129f,     -1.1653f,     -1.2738f,     -1.4254f,     -1.3996f,     -1.2860f,     -1.1124f,     -0.7741f,     -0.3187f,      0.8581f,      0.8470},
    {      1.3511f,      1.4124f,      1.2478f,      1.4679f,      1.8368f,      1.2180f,      0.5979f,      1.1792f,      1.4015f,     -1.2558f,     -1.1972f,     -1.3612f,     -1.3482f,     -1.4692f,     -1.3517f,     -1.3896f,     -1.3764f,     -1.1301f,     -0.5614f,      1.2188f,      1.3700},
    {      1.2742f,      1.4283f,      1.5152f,      1.6518f,      1.4289f,      1.3601f,     -3.1416f,      1.3305f,      0.4412f,     -1.1536f,     -1.3162f,     -1.4203f,     -1.4508f,     -1.5934f,      3.1416f,     -1.1329f,     -1.3949f,     -1.3179f,     -0.9902f,      1.0620f,      1.2796},
    {      1.5906f,      1.4812f,      1.6903f,      1.5156f,     -3.1416f,      1.4850f,      1.4568f,      1.2892f,      1.9913f,     -1.5655f,     -1.5463f,     -1.5576f,     -1.5176f,     -1.6609f,     -1.5680f,     -1.4173f,     -1.2533f,     -1.6209f,     -0.6804f,      1.1690f,      1.5906},
    {      1.7939f,      1.6022f,      1.5717f,     -3.1416f,     -3.1416f,      1.5885f,      1.5484f,      1.5931f,     -3.1416f,     -2.0315f,     -1.6128f,     -1.3268f,     -1.5717f,     -1.5915f,     -1.5978f,     -1.5885f,     -1.6126f,     -1.7847f,      3.1416f,     -3.1416f,      1.7939},
    {      2.0083f,      1.7668f,      1.8463f,      1.6771f,      1.6522f,      1.7859f,      1.6994f,      2.1615f,      1.1348f,     -2.1663f,     -1.6160f,     -1.8137f,     -1.9666f,      3.1416f,      3.1416f,     -1.7994f,     -1.5663f,     -1.6730f,     -0.5723f,      1.9299f,      2.0083},
    {      1.7163f,      1.9687f,      1.7221f,      1.8626f,      1.7985f,      1.7116f,      2.0518f,      2.0671f,     -2.8768f,      3.1300f,     -1.9447f,     -1.8570f,     -2.0905f,     -2.1783f,     -1.9015f,     -1.7470f,     -1.9265f,     -1.8410f,     -2.8060f,      2.0789f,      1.6877},
    {      2.5270f,      1.9207f,      1.6807f,      2.2180f,      2.1377f,      2.1658f,      2.4105f,      1.5206f,      2.7983f,     -1.8223f,     -1.6217f,     -1.6213f,     -2.0144f,     -1.9891f,     -2.0746f,     -1.8540f,     -2.1860f,     -2.2520f,     -2.7290f,      3.0059f,      2.5270},
    {      2.3705f,      2.1304f,      1.9907f,      2.0051f,      2.0683f,      2.3328f,      2.4858f,      2.5043f,      2.8478f,     -2.6268f,     -1.9377f,     -2.2810f,     -1.9288f,     -2.2209f,     -2.0356f,     -2.1561f,     -2.3110f,     -2.4286f,     -2.7978f,      2.3118f,      2.3796},
    {      3.0139f,      2.2994f,      2.1672f,      2.0612f,      2.3852f,      1.9820f,      2.3080f,      2.6085f,      2.8697f,     -2.5443f,     -2.8200f,     -2.0336f,     -2.4895f,     -1.9488f,     -2.2470f,      3.1416f,     -2.4873f,     -2.7765f,     -2.8697f,      2.8607f,      2.8694},
    {      2.8363f,      2.7900f,      2.8283f,      1.9523f,      2.3486f,      2.1829f,      2.5636f,      2.8459f,      2.8425f,     -2.9617f,     -2.3267f,     -2.6022f,     -1.8732f,     -2.8145f,     -2.1081f,     -2.6769f,     -2.8580f,     -2.7495f,     -3.0905f,      2.9088f,      2.8374},
    {      2.6953f,      2.8936f,      2.7861f,      3.1403f,      2.8513f,      2.7738f,      2.9608f,      2.7785f,     -3.1299f,     -3.1257f,     -2.9139f,     -2.9902f,     -2.8156f,     -2.5026f,     -2.9560f,     -2.7680f,     -2.7789f,     -3.1126f,     -2.9621f,      3.0065f,      2.6933},
    {     -3.1365f,     -3.1372f,     -3.1378f,     -3.1361f,     -3.1369f,     -3.1332f,     -3.1296f,     -3.1368f,     -3.1362f,     -3.1367f,     -3.1354f,     -3.1380f,     -3.1372f,     -3.1377f,     -3.1366f,     -3.1380f,     -3.1370f,     -3.1361f,     -3.1383f,     -3.1315f,     -3.1365},
};

static constexpr float alpha_lookup5[19][21] = \
{
    {      0.0059f,     -0.0054f,      0.0036f,     -0.0156f,     -0.0533f,     -0.0064f,     -0.0496f,     -0.0071f,     -0.0110f,     -0.0225f,     -0.0233f,     -0.0069f,     -0.0005f,      0.0025f,      0.0036f,     -0.0473f,     -0.0118f,     -0.0341f,     -0.0076f,     -0.0050f,      0.0059},
    {      0.1771f,      0.1215f,     -0.0942f,      0.0131f,     -0.1506f,     -0.3018f,     -0.3992f,     -0.3389f,     -0.2477f,     -0.3279f,     -0.1509f,     -0.1681f,      0.0666f,      0.1165f,      0.2063f,      0.2401f,      0.3557f,      0.3539f,      0.2837f,      0.3480f,      0.2240},
    {      0.1093f,      0.1398f,     -0.0908f,     -0.3957f,     -0.5041f,     -0.5213f,     -0.5798f,     -0.3817f,     -0.5032f,     -0.4385f,     -0.2306f,      0.0177f,      0.0633f,      0.2663f,      0.3898f,      0.4687f,      0.7153f,      0.5873f,      0.5957f,      0.4080f,      0.1591},
    {      0.3446f,      0.0960f,     -0.1309f,     -0.5672f,     -0.5622f,     -0.7191f,     -0.8404f,     -0.7220f,     -0.8056f,     -0.5586f,     -0.2965f,     -0.1018f,      0.1611f,      0.5618f,      0.6067f,      0.8176f,      0.8241f,      0.7086f,      0.7353f,      0.6738f,      0.2682},
    {      0.2367f,      0.3633f,      0.0535f,     -0.2480f,     -0.6198f,     -0.9510f,     -1.1543f,     -1.2331f,     -1.0141f,     -0.8007f,     -0.4265f,     -0.3100f,      0.1341f,      0.5851f,      0.6453f,      0.9683f,      1.1147f,      0.9642f,      1.0042f,      0.7283f,      0.2531},
    {      0.6624f,      0.0826f,      0.1730f,     -0.4113f,     -0.9265f,     -1.0486f,     -1.2157f,     -1.3186f,     -1.1469f,     -0.8254f,     -0.6484f,     -0.4444f,      0.2236f,      0.4357f,      0.8957f,      1.1194f,      1.2766f,      1.3761f,      1.2070f,      0.8508f,      0.6549},
    {      1.1754f,      0.8376f,     -0.3838f,     -0.8213f,     -1.0876f,     -1.2656f,     -1.3526f,     -1.4517f,     -1.2367f,     -1.1778f,     -0.6934f,     -0.3152f,      1.0790f,      0.9802f,      1.1727f,      1.0203f,      1.2533f,      1.3521f,      1.0182f,      1.2010f,      1.2040},
    {      1.3359f,      1.2290f,     -0.3684f,     -1.1389f,     -1.3764f,     -1.3839f,     -1.3517f,     -1.4912f,     -1.3482f,     -1.3844f,     -1.2199f,     -1.1671f,      1.2664f,      1.1826f,      0.5979f,      1.2691f,      1.8368f,      1.4693f,      1.1919f,      1.4127f,      1.3055},
    {      1.4419f,      0.9844f,     -0.9287f,     -1.2968f,     -1.3949f,     -1.1741f,      3.1416f,     -1.6461f,     -1.4399f,     -1.4199f,     -1.3355f,     -1.1060f,      0.5374f,      1.3324f,     -3.1416f,      1.3925f,      1.4289f,      1.6022f,      1.5142f,      1.3694f,      1.4110},
    {      1.5906f,      1.2028f,     -0.7116f,     -1.5930f,     -1.2533f,     -1.4176f,     -1.5680f,     -1.6125f,     -1.5176f,     -1.4878f,     -1.5463f,     -1.4883f,      1.9913f,      1.3196f,      1.4568f,      1.4813f,     -3.1416f,      1.5128f,      1.6815f,      1.4694f,      1.5906},
    {      1.7939f,     -3.1416f,      3.1416f,     -1.7847f,     -1.6126f,     -1.6166f,     -1.5978f,     -1.5915f,     -1.5717f,     -1.3268f,     -1.6128f,     -2.0315f,     -3.1416f,      1.5931f,      1.5484f,      1.6754f,     -3.1416f,     -3.1416f,      1.5717f,      1.6022f,      1.7939},
    {      2.0083f,      1.9565f,     -0.5746f,     -1.6730f,     -1.5663f,     -1.6960f,      3.1416f,      3.1416f,     -1.9310f,     -1.7879f,     -1.6160f,     -2.1393f,      1.1609f,      2.1615f,      1.6994f,      1.7585f,      1.6522f,      1.6771f,      1.8424f,      1.7510f,      2.0083},
    {      1.5385f,      2.0374f,     -2.8219f,     -1.8497f,     -1.9200f,     -1.7774f,     -1.7677f,     -2.1671f,     -2.0880f,     -1.8998f,     -2.0969f,      3.1166f,     -2.8737f,      2.0807f,      2.0175f,      1.7444f,      1.7712f,      1.8317f,      1.7311f,      1.9319f,      1.5158},
    {      2.5270f,      3.0007f,     -2.7700f,     -2.2281f,     -2.1802f,     -1.7252f,     -2.0470f,     -1.9692f,     -2.0700f,     -1.6268f,     -1.6217f,     -1.8174f,      2.7301f,      1.5125f,      2.3964f,      2.1286f,      2.1136f,      2.2637f,      1.7122f,      1.9065f,      2.5270},
    {      2.1561f,      2.2102f,     -2.7986f,     -2.4420f,     -2.3523f,     -2.1446f,     -2.0128f,     -2.2195f,     -1.9632f,     -2.2666f,     -2.1371f,     -2.7173f,      2.8880f,      2.4832f,      2.4080f,      2.2624f,      2.0876f,      2.0267f,      2.0213f,      2.1550f,      2.1614},
    {      2.8030f,      2.9032f,     -2.9154f,     -2.8163f,     -2.4824f,      3.1416f,     -2.2346f,     -1.9869f,     -2.5180f,     -1.9938f,     -2.8776f,     -2.4829f,      2.9741f,      2.6026f,      2.3457f,      1.9820f,      2.3946f,      1.9432f,      2.0151f,      2.3360f,      2.7198},
    {      2.7753f,      2.9506f,     -3.0802f,     -3.0406f,     -2.8334f,     -2.5843f,     -2.1262f,     -2.8303f,     -1.7992f,     -2.6156f,     -2.3660f,     -2.9084f,      2.9505f,      2.8256f,      2.5651f,      2.0378f,      2.3563f,      1.7222f,      2.8274f,      2.7812f,      2.7826},
    {      2.5122f,      2.9807f,     -2.8112f,     -3.1086f,     -2.7593f,     -2.7402f,     -2.9134f,     -2.4961f,     -2.8212f,     -2.9604f,     -2.9054f,     -3.1135f,     -3.1368f,      2.7916f,      2.9817f,      2.7782f,      2.7801f,      3.1407f,      2.6977f,      2.8875f,      2.5195},
    {     -3.1365f,     -3.1353f,     -3.1340f,     -3.1334f,     -3.1360f,     -3.1323f,     -3.1293f,     -3.1337f,     -3.1354f,     -3.1357f,     -3.1346f,     -3.1352f,     -3.1353f,     -3.1343f,     -3.1333f,     -3.1356f,     -3.1351f,     -3.1348f,     -3.1352f,     -3.1310f,     -3.1365},
};

static constexpr float alpha_lookup6[19][21] = \
{
    {      0.0148f,      0.0280f,      0.0017f,      0.0229f,      0.0255f,      0.0028f,      0.0856f,      0.0655f,     -0.0009f,      0.0599f,      0.0737f,      0.0162f,     -0.0019f,      0.0676f,     -0.0080f,      0.0052f,      0.0429f,      0.0353f,      0.0710f,      0.0328f,      0.0148},
    {     -0.0916f,     -0.1661f,      0.0553f,      0.1453f,      0.2150f,      0.2608f,      0.2883f,      0.3678f,      0.2854f,      0.3509f,      0.0783f,      0.1180f,     -0.0898f,     -0.0634f,     -0.1527f,     -0.3475f,     -0.3863f,     -0.3850f,     -0.2408f,     -0.3324f,     -0.0842},
    {     -0.3418f,     -0.0417f,      0.0821f,      0.1396f,      0.0829f,      0.5846f,      0.6379f,      0.6292f,      0.5901f,      0.3812f,      0.1258f,      0.1400f,     -0.1032f,     -0.4710f,     -0.3900f,     -0.5789f,     -0.5514f,     -0.5166f,     -0.4984f,     -0.4171f,     -0.2585},
    {     -0.3366f,     -0.2505f,      0.1100f,      0.5608f,      0.6779f,      0.8257f,      0.8015f,      0.7287f,      0.7177f,      0.5549f,      0.3493f,      0.0450f,     -0.0978f,     -0.5768f,     -0.7021f,     -0.6763f,     -0.8335f,     -0.7454f,     -0.8228f,     -0.5848f,     -0.4222},
    {     -0.3456f,     -0.0923f,      0.1401f,      0.8389f,      0.6707f,      0.8607f,      1.0918f,      1.0559f,      0.9040f,      0.8447f,      0.3282f,      0.2083f,     -0.1495f,     -0.2324f,     -0.6693f,     -0.8874f,     -1.1530f,     -1.0967f,     -1.0116f,     -0.8495f,     -0.3286},
    {     -0.7243f,     -0.3468f,      0.1967f,      0.5632f,      1.0073f,      1.1458f,      1.2979f,      1.3955f,      1.2366f,      0.9235f,      0.6534f,      0.0110f,      0.0363f,     -0.6315f,     -0.9543f,     -1.0910f,     -1.2632f,     -1.3999f,     -1.1939f,     -0.9820f,     -0.6841},
    {     -0.6434f,     -0.4605f,      0.9990f,      0.9218f,      1.1803f,      1.3700f,      1.2739f,      1.3606f,      0.9787f,      1.1798f,      0.9033f,      0.8449f,     -0.2788f,     -0.7494f,     -1.0057f,     -1.1893f,     -1.2923f,     -1.4310f,     -1.2320f,     -1.1906f,     -0.6421},
    {     -1.1462f,     -1.0754f,      1.2729f,      1.2188f,      0.5569f,      1.4451f,      1.6834f,      1.4686f,      1.1386f,      1.3766f,      1.4476f,      1.1539f,     -0.3103f,     -1.1113f,     -1.3100f,     -1.3456f,     -1.3349f,     -1.4640f,     -1.3956f,     -1.3868f,     -1.1692},
    {     -1.4437f,     -1.5171f,      0.5985f,      1.3576f,     -3.1416f,      1.5132f,      1.4486f,      1.6201f,      1.5439f,      1.4452f,      1.3492f,      1.0334f,     -0.9351f,     -1.3021f,     -1.3875f,     -1.7059f,      3.1416f,     -1.6063f,     -1.4443f,     -1.5699f,     -1.4422},
    {     -1.4816f,     -1.4510f,      0.7100f,      1.7139f,      1.5222f,      1.4652f,     -3.1416f,      1.6554f,      1.5559f,      1.5492f,      1.4732f,      1.6033f,      3.1416f,     -1.3447f,     -1.3655f,     -1.5223f,     -1.6447f,     -1.5906f,     -1.6802f,     -1.5779f,     -1.4816},
    {     -1.5385f,      3.1416f,     -3.1416f,      1.6465f,      1.5755f,      1.5989f,     -3.1416f,     -3.1416f,      1.5717f,      1.5839f,      1.6754f,     -3.1416f,      3.1416f,     -1.9092f,     -1.6315f,     -1.6658f,     -1.6117f,     -1.6291f,     -1.5717f,     -1.6022f,     -1.5385},
    {     -1.5371f,     -2.3810f,      0.7754f,      2.0273f,      1.6832f,      1.6201f,      1.6317f,      1.6260f,      1.9783f,      1.7392f,      1.8777f,      1.9498f,     -1.4793f,     -1.6285f,     -1.5330f,     -1.7857f,      3.1416f,      3.1416f,     -1.8630f,     -1.9161f,     -1.5371},
    {     -2.0384f,      3.0641f,      2.8314f,      2.2731f,      2.2019f,      1.8701f,      1.7840f,      1.8527f,      1.7603f,      1.5155f,      1.6419f,      2.0836f,     -1.8497f,     -1.4921f,     -2.0667f,     -1.9468f,     -1.9652f,     -2.1278f,     -1.5770f,     -1.9863f,     -2.0901},
    {     -1.5367f,     -1.8685f,      2.7680f,      1.7648f,      2.3239f,      1.4690f,      2.0809f,      2.2998f,      1.7067f,      1.9766f,      2.4272f,      3.0694f,     -2.6395f,     -2.0634f,     -2.4135f,     -1.8666f,     -2.1945f,     -1.9184f,     -1.7500f,     -1.6379f,     -1.5367},
    {     -1.9064f,     -2.2191f,      2.9233f,      2.5304f,      2.1924f,      2.1934f,      1.9994f,      2.1642f,      1.8650f,      2.4451f,      2.3747f,      2.7497f,     -2.8709f,     -2.3869f,     -2.3026f,     -2.5221f,     -1.9277f,     -2.1581f,     -2.0281f,     -2.1265f,     -1.8984},
    {     -2.6763f,     -2.7324f,      2.8742f,      2.6166f,      2.3190f,      2.0160f,      2.4287f,      1.9243f,      2.3086f,      2.0601f,      2.6106f,      2.7754f,     -2.8148f,     -2.9241f,     -2.5202f,      3.1416f,     -2.2786f,     -1.9203f,     -2.3094f,     -2.2715f,     -2.6623},
    {     -2.3378f,     -2.9881f,      2.8044f,      2.8608f,      2.5794f,      2.6758f,      2.4520f,      2.1798f,      2.7279f,      2.7533f,      2.6419f,      2.9547f,     -3.0137f,     -2.7464f,     -2.8313f,     -2.6153f,     -1.8351f,     -1.2079f,     -2.0327f,     -2.3783f,     -2.3431},
    {     -2.9500f,     -3.1067f,     -3.0814f,      2.6192f,      2.9033f,      2.8413f,      2.8326f,      3.1316f,      2.8453f,      2.8252f,      2.6694f,      3.0730f,     -3.0303f,     -3.0084f,     -2.8929f,     -2.9191f,     -2.9699f,     -2.4710f,     -2.8585f,     -2.9475f,     -2.9450},
    {     -3.1400f,     -3.1384f,     -3.1371f,     -3.1386f,     -3.1391f,     -3.1399f,     -3.1409f,     -3.1380f,     -3.1401f,     -3.1395f,     -3.1396f,     -3.1377f,     -3.1390f,     -3.1375f,     -3.1383f,     -3.1384f,     -3.1391f,     -3.1397f,     -3.1377f,     -3.1408f,     -3.1400},
};
static constexpr float phi_range[21] = {     -3.1416f,     -2.8274f,     -2.5133f,     -2.1991f,     -1.8850f,     -1.5708f,     -1.2566f,     -0.9425f,     -0.6283f,     -0.3142f,      0.0000f,      0.3142f,      0.6283f,      0.9425f,      1.2566f,      1.5708f,      1.8850f,      2.1991f,      2.5133f,      2.8274f,      3.1416f};
static constexpr float theta_range[19] = {     -1.5708f,     -1.3963f,     -1.2217f,     -1.0472f,     -0.8727f,     -0.6981f,     -0.5236f,     -0.3491f,     -0.1745f,      0.0000f,      0.1745f,      0.3491f,      0.5236f,      0.6981f,      0.8727f,      1.0472f,      1.2217f,      1.3963f,      1.5708f};

class MulticopterAttitudeControl
{
public:
	/**
	 * Constructor
	 */
	MulticopterAttitudeControl();

	/**
	 * Destructor, also kills the main task
	 */
	~MulticopterAttitudeControl();

	/**
	 * Start the multicopter attitude control task.
	 *	 * @return		OK on success.
	 */
	int		start();

private:

	bool	_task_should_exit;		/**< if true, task_main() should exit */
	int		_control_task;			/**< task handle */

	int		_ctrl_state_sub;		/**< control state subscription */
	int		_v_att_sp_sub;			/**< vehicle attitude setpoint subscription */
    int     _vol_thrust_sp_sub;     /**< vehicle thrust setpoint subscription, added by voliro */
	int		_v_rates_sp_sub;		/**< vehicle rates setpoint subscription */
	int		_v_control_mode_sub;	/**< vehicle control mode subscription */
	int		_params_sub;			/**< parameter updates subscription */
	int		_manual_control_sp_sub;	/**< manual control setpoint subscription */
	int		_armed_sub;				/**< arming status subscription */
	int		_vehicle_status_sub;	/**< vehicle status subscription */
	int 	_motor_limits_sub;		/**< motor limits subscription */
	int 	_battery_status_sub;	/**< battery status subscription */

	orb_advert_t	_v_rates_sp_pub;		/**< rate setpoint publication */
	orb_advert_t	_actuators_0_pub;		/**< attitude actuator controls publication */
    orb_advert_t	_actuators_1_pub;          /**< alpha actuator controls publication, added by voliro */
	orb_advert_t	_controller_status_pub;	/**< controller status publication */

	orb_id_t _rates_sp_id;	/**< pointer to correct rates setpoint uORB metadata structure */
	orb_id_t _actuators_id;	/**< pointer to correct actuator controls0 uORB metadata structure */
    orb_id_t _actuators_1_id;	/**< pointer to correct actuator controls1 uORB metadata structure, added by voliro */

    bool		_actuators_0_circuit_breaker_enabled;	/**< circuit breaker to suppress output */
    bool		_actuators_1_circuit_breaker_enabled;	/**< circuit breaker to suppress output */

    struct control_state_s              _ctrl_state;		/**< control state */
    struct vehicle_attitude_setpoint_s	_v_att_sp;		/**< vehicle attitude setpoint */
    struct voliro_thrust_setpoint_s     _vol_thrust_sp;          /**< vehicle thrust setpoint, added by voliro */
	struct vehicle_rates_setpoint_s		_v_rates_sp;		/**< vehicle rates setpoint */
	struct manual_control_setpoint_s	_manual_control_sp;	/**< manual control setpoint */
	struct vehicle_control_mode_s		_v_control_mode;	/**< vehicle control mode */
    struct actuator_controls_s          _actuators;		/**< actuator controls, omega */
    struct actuator_controls_s          _actuators_1;            /**< alpha controls, added by voliro */
    struct actuator_armed_s             _armed;			/**< actuator arming status */
    struct vehicle_status_s             _vehicle_status;	/**< vehicle status */
	struct multirotor_motor_limits_s	_motor_limits;		/**< motor limits */
    struct mc_att_ctrl_status_s 		_controller_status;     /**< controller status */
    struct battery_status_s				_battery_status;/**< battery status */




	perf_counter_t	_loop_perf;			/**< loop performance counter */
	perf_counter_t	_controller_latency_perf;

	math::Vector<3>		_rates_prev;	/**< angular rates on previous step */
    math::Vector<3>		_att_err_prev;  /**< attitude error on previous step */   //AbV
	math::Vector<3>		_rates_sp_prev; /**< previous rates setpoint */
	math::Vector<3>		_rates_sp;		/**< angular rates setpoint */
	math::Vector<3>		_rates_int;		/**< angular rates integral error */

    math::Vector<3>		_att_int;		/**< attitude integral error */     //AbV
	float				_thrust_sp;		/**< thrust setpoint */
	math::Vector<3>		_att_control;	/**< attitude control vector */
    math::Vector<6>     _alpha_des;     /**< _alpha_des, is sent to actuator control */
    math::Vector<6>     _alpha_prev;     /**< Previous desired alpha*/
    math::Vector<6>     _alpha_sim;     /**< Simulated alpha*/
    math::Vector<6>     _alpha_sim_prev; /**< Previous simulated alpha */
    math::Vector<6>     _omega_des;     /**< omega_des, is sent to actuator control */
	math::Matrix<3, 3>  _I;				/**< identity matrix */
    math::Vector<3>     _vol_att_sp;      /**< attitude setpoint, added by voliro*/

	struct {
		param_t roll_p;
    param_t roll_d;     //AbV
    param_t roll_i;     //AbV
    param_t roll_integ_lim;  //AbV
		param_t roll_rate_p;
		param_t roll_rate_i;
		param_t roll_rate_d;
		param_t roll_rate_ff;
		param_t pitch_p;
    param_t pitch_d;     //AbV
    param_t pitch_i;     //AbV
    param_t pitch_integ_lim;  //AbV
		param_t pitch_rate_p;
		param_t pitch_rate_i;
		param_t pitch_rate_d;
		param_t pitch_rate_ff;
		param_t tpa_breakpoint;
		param_t tpa_slope;
		param_t yaw_p;
        param_t yaw_d;     //AbV
        param_t yaw_i;     //AbV
        param_t yaw_integ_lim;  //AbV
		param_t yaw_rate_p;
		param_t yaw_rate_i;
		param_t yaw_rate_d;
		param_t yaw_rate_ff;
		param_t yaw_ff;
		param_t roll_rate_max;
		param_t pitch_rate_max;
		param_t yaw_rate_max;
		param_t yaw_auto_max;

		param_t acro_roll_max;
		param_t acro_pitch_max;
		param_t acro_yaw_max;
		param_t rattitude_thres;

		param_t vtol_type;
		param_t roll_tc;
		param_t pitch_tc;
		param_t vtol_opt_recovery_enabled;
		param_t vtol_wv_yaw_rate_scale;

		param_t bat_scale_en;

    param_t tau_servo; //added by Voliro

        //added by Voliro
    param_t length_axis;
		param_t torque_coeff;

	}		_params_handles;		/**< handles for interesting parameters */

	struct {
		math::Vector<3> att_p;					/**< P gain for angular error */
    math::Vector<3> att_d;	//AbV		/**< D gain for angular error */
    math::Vector<3> att_i;	//AbV		/**< I gain for angular error */
    math::Vector<3> att_int_lim; //AbV	/**< integrator state limit for angular loop */
		math::Vector<3> rate_p;				/**< P gain for angular rate error */
		math::Vector<3> rate_i;				/**< I gain for angular rate error */
		math::Vector<3> rate_d;				/**< D gain for angular rate error */
		math::Vector<3>	rate_ff;			/**< Feedforward gain for desired rates */
		float yaw_ff;						/**< yaw control feed-forward */

		float tpa_breakpoint;				/**< Throttle PID Attenuation breakpoint */
		float tpa_slope;					/**< Throttle PID Attenuation slope */

		float roll_rate_max;
		float pitch_rate_max;
		float yaw_rate_max;
		float yaw_auto_max;
		math::Vector<3> mc_rate_max;		/**< attitude rate limits in stabilized modes */
		math::Vector<3> auto_rate_max;		/**< attitude rate limits in auto modes */
		math::Vector<3> acro_rate_max;		/**< max attitude rates in acro mode */
		float rattitude_thres;
		int vtol_type;						/**< 0 = Tailsitter, 1 = Tiltrotor, 2 = Standard airframe */
		bool vtol_opt_recovery_enabled;
		float vtol_wv_yaw_rate_scale;			/**< Scale value [0, 1] for yaw rate setpoint  */

		int bat_scale_en;

        //added by Voliro
        float length_axis;
        float torque_coeff;
        float tau_servo;

	}		_params;



    TailsitterRecovery *_ts_opt_recovery;	/**< Computes optimal rates for tailsitter recovery */

	/**
	 * Update our local parameter cache.
	 */
	int			parameters_update();

	/**
	 * Check for parameter update and handle it.
	 */
	void		parameter_update_poll();

	/**
	 * Check for changes in vehicle control mode.
	 */
	void		vehicle_control_mode_poll();

	/**
	 * Check for changes in manual inputs.
	 */
	void		vehicle_manual_poll();

	/**
	 * Check for attitude setpoint updates.
	 */
	void		vehicle_attitude_setpoint_poll();

    /**
     * Check for thrust setpoint updates.
     */
    void        voliro_thrust_setpoint_poll();

	/**
	 * Check for rates setpoint updates.
	 */
	void		vehicle_rates_setpoint_poll();

	/**
	 * Check for arming status updates.
	 */
	void		arming_status_poll();

	/**
	 * Attitude controller.
	 */
	void		control_attitude(float dt);

	/**
	 * Attitude rates controller.
	 */
	void		control_attitude_rates(float dt);

  /**
   *functions that looks up alpha in table and simulates motor dynamics.
   */
  void alpha(float dt);

    /**
     * Control Allocation
     */
  void		control_allocation(float dt);

    /**
     *Gives back value of lookup table
     */
    float value_lookup(unsigned index_phi, unsigned index_theta, unsigned iterator);
    /**
     *Gives back interpolated data of lookup table
     */
    void lookup(float theta, float phi, math::Vector<6> (&a));

    /**
	 * Check for vehicle status updates.
	 */
	void		vehicle_status_poll();

	/**
	 * Check for vehicle motor limits status.
	 */
	void		vehicle_motor_limits_poll();

	/**
	 * Check for battery status updates.
	 */
	void		battery_status_poll();

	/**
	 * Shim for calling task_main from task_create.
	 */
	static void	task_main_trampoline(int argc, char *argv[]);

	/**
	 * Main attitude control task.
	 */
	void		task_main();
};




namespace mc_att_control
{

MulticopterAttitudeControl	*g_control;
}

MulticopterAttitudeControl::MulticopterAttitudeControl() :

	_task_should_exit(false),
	_control_task(-1),

	/* subscriptions */
	_ctrl_state_sub(-1),
	_v_att_sp_sub(-1),
  _vol_thrust_sp_sub(-1),
	_v_control_mode_sub(-1),
	_params_sub(-1),
	_manual_control_sp_sub(-1),
	_armed_sub(-1),
	_vehicle_status_sub(-1),

	/* publications */
	_v_rates_sp_pub(nullptr),
  _actuators_0_pub(nullptr),
  _actuators_1_pub(nullptr), //added by voliro

	_controller_status_pub(nullptr),
	_rates_sp_id(0),
    _actuators_id(0),
    _actuators_1_id(0),//added by voliro

	_actuators_0_circuit_breaker_enabled(false),
    _actuators_1_circuit_breaker_enabled(false),


	/* performance counters */
	_loop_perf(perf_alloc(PC_ELAPSED, "mc_att_control")),
	_controller_latency_perf(perf_alloc_once(PC_ELAPSED, "ctrl_latency")),
	_ts_opt_recovery(nullptr)

{
	memset(&_ctrl_state, 0, sizeof(_ctrl_state));
	memset(&_v_att_sp, 0, sizeof(_v_att_sp));
	memset(&_v_rates_sp, 0, sizeof(_v_rates_sp));
	memset(&_manual_control_sp, 0, sizeof(_manual_control_sp));
	memset(&_v_control_mode, 0, sizeof(_v_control_mode));
	memset(&_actuators, 0, sizeof(_actuators));
    memset(&_actuators_1, 0, sizeof(_actuators_1));
	memset(&_armed, 0, sizeof(_armed));
	memset(&_vehicle_status, 0, sizeof(_vehicle_status));
	memset(&_motor_limits, 0, sizeof(_motor_limits));
	memset(&_controller_status, 0, sizeof(_controller_status));
	_vehicle_status.is_rotary_wing = true;

  _params.att_p.zero();
  _params.att_d.zero();   //AbV
  _params.att_i.zero();   //AbV
  _params.att_int_lim.zero();   //AbV
  _params.rate_p.zero();
	_params.rate_i.zero();
	_params.rate_d.zero();
	_params.rate_ff.zero();
	_params.yaw_ff = 0.0f;
	_params.roll_rate_max = 0.0f;
	_params.pitch_rate_max = 0.0f;
	_params.yaw_rate_max = 0.0f;
	_params.mc_rate_max.zero();
	_params.auto_rate_max.zero();
	_params.acro_rate_max.zero();
	_params.rattitude_thres = 1.0f;
	_params.vtol_opt_recovery_enabled = false;
	_params.vtol_wv_yaw_rate_scale = 1.0f;
	_params.bat_scale_en = 0;

	_rates_prev.zero();
    _att_err_prev.zero();   //AbV
	_rates_sp.zero();
	_rates_sp_prev.zero();
	_rates_int.zero();
    _att_int.zero();    //AbV
    _alpha_prev.zero();
    _alpha_sim.zero();
    _alpha_sim_prev.zero();
	_thrust_sp = 0.0f;
	_att_control.zero();

	_I.identity();

  //Added by Voliro
  _params.length_axis = 0.375f;
  _params.torque_coeff = 0.016f;
  _params.tau_servo = 0.0f;

	_params_handles.roll_p				= 	param_find("MC_ROLL_P");
  _params_handles.roll_d				= 	param_find("MC_ROLL_D");    //AbV
  _params_handles.roll_i				= 	param_find("MC_ROLL_I");    //AbV
  _params_handles.roll_integ_lim	= 	param_find("MC_R_INT_LIM"); //AbV
  _params_handles.roll_rate_p		= 	param_find("MC_ROLLRATE_P");
	_params_handles.roll_rate_i		= 	param_find("MC_ROLLRATE_I");
  // _params_handles.roll_rate_integ_lim	= 	param_find("MC_RR_INT_LIM");
	_params_handles.roll_rate_d		= 	param_find("MC_ROLLRATE_D");
	_params_handles.roll_rate_ff	= 	param_find("MC_ROLLRATE_FF");
  _params_handles.pitch_p				= 	param_find("MC_PITCH_P");
  _params_handles.pitch_d				= 	param_find("MC_PITCH_D");   //AbV
  _params_handles.pitch_i				= 	param_find("MC_PITCH_I");   //AbV
  _params_handles.pitch_integ_lim	= 	param_find("MC_P_INT_LIM"); //AbV
	_params_handles.pitch_rate_p	= 	param_find("MC_PITCHRATE_P");
	_params_handles.pitch_rate_i	= 	param_find("MC_PITCHRATE_I");
	_params_handles.pitch_rate_d	= 	param_find("MC_PITCHRATE_D");
	_params_handles.pitch_rate_ff 	= 	param_find("MC_PITCHRATE_FF");
	_params_handles.tpa_breakpoint 	= 	param_find("MC_TPA_BREAK");
	_params_handles.tpa_slope	 	= 	param_find("MC_TPA_SLOPE");
	_params_handles.yaw_p			=	param_find("MC_YAW_P");
    _params_handles.yaw_d			=	param_find("MC_YAW_D");   //AbV
    _params_handles.yaw_i			=	param_find("MC_YAW_I");   //AbV
    _params_handles.yaw_integ_lim	= 	param_find("MC_Y_INT_LIM");//AbV
	_params_handles.yaw_rate_p		= 	param_find("MC_YAWRATE_P");
	_params_handles.yaw_rate_i		= 	param_find("MC_YAWRATE_I");
	_params_handles.yaw_rate_d		= 	param_find("MC_YAWRATE_D");
	_params_handles.yaw_rate_ff	 	= 	param_find("MC_YAWRATE_FF");
	_params_handles.yaw_ff				= 	param_find("MC_YAW_FF");
	_params_handles.roll_rate_max	= 	param_find("MC_ROLLRATE_MAX");
	_params_handles.pitch_rate_max= 	param_find("MC_PITCHRATE_MAX");
	_params_handles.yaw_rate_max	= 	param_find("MC_YAWRATE_MAX");
	_params_handles.yaw_auto_max	= 	param_find("MC_YAWRAUTO_MAX");
	_params_handles.acro_roll_max	= 	param_find("MC_ACRO_R_MAX");
	_params_handles.acro_pitch_max= 	param_find("MC_ACRO_P_MAX");
	_params_handles.acro_yaw_max	= 	param_find("MC_ACRO_Y_MAX");
	_params_handles.rattitude_thres = 	param_find("MC_RATT_TH");
	_params_handles.vtol_type 		= 	param_find("VT_TYPE");
	_params_handles.roll_tc				= 	param_find("MC_ROLL_TC");
	_params_handles.pitch_tc			= 	param_find("MC_PITCH_TC");
	_params_handles.vtol_opt_recovery_enabled	= param_find("VT_OPT_RECOV_EN");
	_params_handles.vtol_wv_yaw_rate_scale		= param_find("VT_WV_YAWR_SCL");
	_params_handles.bat_scale_en		= param_find("MC_BAT_SCALE_EN");

    //Added by Voliro
    _params_handles.length_axis     =   param_find("MC_LENGTH_AXIS");
    _params_handles.torque_coeff    =   param_find("MC_TORQUE_COEFF");
    _params_handles.tau_servo       =   param_find("TAU_SERVO");

	/* fetch initial parameter values */
	parameters_update();

	if (_params.vtol_type == 0 && _params.vtol_opt_recovery_enabled) {
		// the vehicle is a tailsitter, use optimal recovery control strategy
		_ts_opt_recovery = new TailsitterRecovery();
	}



}

MulticopterAttitudeControl::~MulticopterAttitudeControl()
{
	if (_control_task != -1) {
		/* task wakes up every 100ms or so at the longest */
		_task_should_exit = true;

		/* wait for a second for the task to quit at our request */
		unsigned i = 0;

		do {
			/* wait 20ms */
			usleep(20000);

			/* if we have given up, kill it */
			if (++i > 50) {
				px4_task_delete(_control_task);
				break;
			}
		} while (_control_task != -1);
	}

	if (_ts_opt_recovery != nullptr) {
		delete _ts_opt_recovery;
	}

	mc_att_control::g_control = nullptr;
}



int
MulticopterAttitudeControl::parameters_update()
{
	float v;

	float roll_tc, pitch_tc;

	param_get(_params_handles.roll_tc, &roll_tc);
	param_get(_params_handles.pitch_tc, &pitch_tc);

	/* roll gains */
	param_get(_params_handles.roll_p, &v);
	_params.att_p(0) = v * (ATTITUDE_TC_DEFAULT / roll_tc);
    param_get(_params_handles.roll_i, &v); //AbV
    _params.att_i(0) = v;
    param_get(_params_handles.roll_integ_lim, &v); //AbV
    _params.att_int_lim(0) = v;
    param_get(_params_handles.roll_d, &v); //AbV
    _params.att_d(0) = v * (ATTITUDE_TC_DEFAULT / roll_tc);
    param_get(_params_handles.roll_rate_p, &v);
    _params.rate_p(0) = v * (ATTITUDE_TC_DEFAULT / roll_tc);
    param_get(_params_handles.roll_rate_i, &v);
	_params.rate_i(0) = v;
	param_get(_params_handles.roll_rate_d, &v);
	_params.rate_d(0) = v * (ATTITUDE_TC_DEFAULT / roll_tc);
	param_get(_params_handles.roll_rate_ff, &v);
	_params.rate_ff(0) = v;

	/* pitch gains */
	param_get(_params_handles.pitch_p, &v);
	_params.att_p(1) = v * (ATTITUDE_TC_DEFAULT / pitch_tc);
    param_get(_params_handles.pitch_i, &v); //AbV
    _params.att_i(1) = v;
    param_get(_params_handles.pitch_integ_lim, &v); //AbV
    _params.att_int_lim(1) = v;
    param_get(_params_handles.pitch_d, &v); //AbV
    _params.att_d(1) = v * (ATTITUDE_TC_DEFAULT / pitch_tc);
	param_get(_params_handles.pitch_rate_p, &v);
	_params.rate_p(1) = v * (ATTITUDE_TC_DEFAULT / pitch_tc);
	param_get(_params_handles.pitch_rate_i, &v);
	_params.rate_i(1) = v;
	param_get(_params_handles.pitch_rate_d, &v);
	_params.rate_d(1) = v * (ATTITUDE_TC_DEFAULT / pitch_tc);
	param_get(_params_handles.pitch_rate_ff, &v);
	_params.rate_ff(1) = v;

	param_get(_params_handles.tpa_breakpoint, &v);
	_params.tpa_breakpoint = v;
	param_get(_params_handles.tpa_slope, &v);
	_params.tpa_slope = v;

	/* yaw gains */
	param_get(_params_handles.yaw_p, &v);
	_params.att_p(2) = v;
    param_get(_params_handles.yaw_i, &v); //AbV
    _params.att_i(2) = v;
    param_get(_params_handles.yaw_integ_lim, &v); //AbV
    _params.att_int_lim(2) = v;
    param_get(_params_handles.yaw_d, &v); //AbV
    _params.att_d(2) = v;
	param_get(_params_handles.yaw_rate_p, &v);
	_params.rate_p(2) = v;
	param_get(_params_handles.yaw_rate_i, &v);
	_params.rate_i(2) = v;
	param_get(_params_handles.yaw_rate_d, &v);
	_params.rate_d(2) = v;
	param_get(_params_handles.yaw_rate_ff, &v);
	_params.rate_ff(2) = v;

	param_get(_params_handles.yaw_ff, &_params.yaw_ff);

	/* angular rate limits */
	param_get(_params_handles.roll_rate_max, &_params.roll_rate_max);
	_params.mc_rate_max(0) = math::radians(_params.roll_rate_max);
	param_get(_params_handles.pitch_rate_max, &_params.pitch_rate_max);
	_params.mc_rate_max(1) = math::radians(_params.pitch_rate_max);
	param_get(_params_handles.yaw_rate_max, &_params.yaw_rate_max);
	_params.mc_rate_max(2) = math::radians(_params.yaw_rate_max);

	/* auto angular rate limits */
	param_get(_params_handles.roll_rate_max, &_params.roll_rate_max);
	_params.auto_rate_max(0) = math::radians(_params.roll_rate_max);
	param_get(_params_handles.pitch_rate_max, &_params.pitch_rate_max);
	_params.auto_rate_max(1) = math::radians(_params.pitch_rate_max);
	param_get(_params_handles.yaw_auto_max, &_params.yaw_auto_max);
	_params.auto_rate_max(2) = math::radians(_params.yaw_auto_max);

	/* manual rate control scale and auto mode roll/pitch rate limits */
	param_get(_params_handles.acro_roll_max, &v);
	_params.acro_rate_max(0) = math::radians(v);
	param_get(_params_handles.acro_pitch_max, &v);
	_params.acro_rate_max(1) = math::radians(v);
	param_get(_params_handles.acro_yaw_max, &v);
	_params.acro_rate_max(2) = math::radians(v);

	/* stick deflection needed in rattitude mode to control rates not angles */
	param_get(_params_handles.rattitude_thres, &_params.rattitude_thres);

	param_get(_params_handles.vtol_type, &_params.vtol_type);

	int tmp;
	param_get(_params_handles.vtol_opt_recovery_enabled, &tmp);
	_params.vtol_opt_recovery_enabled = (bool)tmp;

	param_get(_params_handles.vtol_wv_yaw_rate_scale, &_params.vtol_wv_yaw_rate_scale);

	param_get(_params_handles.bat_scale_en, &_params.bat_scale_en);

	_actuators_0_circuit_breaker_enabled = circuit_breaker_enabled("CBRK_RATE_CTRL", CBRK_RATE_CTRL_KEY);
    _actuators_1_circuit_breaker_enabled = circuit_breaker_enabled("CBRK_RATE_CTRL", CBRK_RATE_CTRL_KEY);
	param_get(_params_handles.tau_servo, &(_params_handles.tau_servo));

  /*Parameters added by voliro*/
  param_get(_params_handles.length_axis, &(_params.length_axis));
  param_get(_params_handles.torque_coeff, &(_params.torque_coeff));



	return OK;
}

void
MulticopterAttitudeControl::parameter_update_poll()
{
	bool updated;

	/* Check if parameters have changed */
	orb_check(_params_sub, &updated);

	if (updated) {
		struct parameter_update_s param_update;
		orb_copy(ORB_ID(parameter_update), _params_sub, &param_update);
		parameters_update();
	}
}

void
MulticopterAttitudeControl::vehicle_control_mode_poll()
{
	bool updated;

	/* Check if vehicle control mode has changed */
	orb_check(_v_control_mode_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(vehicle_control_mode), _v_control_mode_sub, &_v_control_mode);
	}
}

void
MulticopterAttitudeControl::vehicle_manual_poll()
{
	bool updated;

	/* get pilots inputs */
	orb_check(_manual_control_sp_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(manual_control_setpoint), _manual_control_sp_sub, &_manual_control_sp);
	}
}

void
MulticopterAttitudeControl::vehicle_attitude_setpoint_poll()
{
	/* check if there is a new setpoint */
	bool updated;
	orb_check(_v_att_sp_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(vehicle_attitude_setpoint), _v_att_sp_sub, &_v_att_sp);
	}
}

void
MulticopterAttitudeControl::voliro_thrust_setpoint_poll()
{
    /* check if there is a new setpoint */
    bool updated;
    orb_check(_vol_thrust_sp_sub, &updated);

    if (updated) {
        orb_copy(ORB_ID(voliro_thrust_setpoint), _vol_thrust_sp_sub, &_vol_thrust_sp);
    }
}

void
MulticopterAttitudeControl::vehicle_rates_setpoint_poll()
{
	/* check if there is a new setpoint */
	bool updated;
	orb_check(_v_rates_sp_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(vehicle_rates_setpoint), _v_rates_sp_sub, &_v_rates_sp);
	}
}

void
MulticopterAttitudeControl::arming_status_poll()
{
	/* check if there is a new setpoint */
	bool updated;
	orb_check(_armed_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(actuator_armed), _armed_sub, &_armed);
	}
}

void
MulticopterAttitudeControl::vehicle_status_poll()
{
	/* check if there is new status information */
	bool vehicle_status_updated;
	orb_check(_vehicle_status_sub, &vehicle_status_updated);

	if (vehicle_status_updated) {
		orb_copy(ORB_ID(vehicle_status), _vehicle_status_sub, &_vehicle_status);

		/* set correct uORB ID, depending on if vehicle is VTOL or not */
		if (!_rates_sp_id) {
			if (_vehicle_status.is_vtol) {
				_rates_sp_id = ORB_ID(mc_virtual_rates_setpoint);
				_actuators_id = ORB_ID(actuator_controls_virtual_mc);

			} else {
				_rates_sp_id = ORB_ID(vehicle_rates_setpoint);
				_actuators_id = ORB_ID(actuator_controls_0);
                _actuators_1_id = ORB_ID(actuator_controls_1);


			}
		}
	}
}

void
MulticopterAttitudeControl::vehicle_motor_limits_poll()
{
	/* check if there is a new message */
	bool updated;
	orb_check(_motor_limits_sub, &updated);


	if (updated) {
		orb_copy(ORB_ID(multirotor_motor_limits), _motor_limits_sub, &_motor_limits);
	}
}

void
MulticopterAttitudeControl::battery_status_poll()
{
	/* check if there is a new message */
	bool updated;
	orb_check(_battery_status_sub, &updated);

	if (updated) {
		orb_copy(ORB_ID(battery_status), _battery_status_sub, &_battery_status);
	}
}

/**
 * Attitude controller.
 * Input: 'vehicle_attitude_setpoint' topics (depending on mode)
 * Output: '_rates_sp' vector, '_thrust_sp'
 */

/* voliro: use _vol_thrust_sp.f[0-2] as input, published by position controller.
    give out _vol_att_sp(0-2) they will be entered into allocation at topic _voliro_actuator_controls_0(omega) und _voliro_actuator_controls_1 (alpha)*/

void
MulticopterAttitudeControl::control_attitude(float dt)
{
	vehicle_attitude_setpoint_poll();
    voliro_thrust_setpoint_poll();


    _thrust_sp = _v_att_sp.thrust;
/*
    / construct attitude setpoint rotation matrix /
	math::Quaternion q_sp(_v_att_sp.q_d[0], _v_att_sp.q_d[1], _v_att_sp.q_d[2], _v_att_sp.q_d[3]);
    math::Matrix<3, 3> R_sp = q_sp.to_dcm();

    / get current rotation matrix from control state quaternions /
	math::Quaternion q_att(_ctrl_state.q[0], _ctrl_state.q[1], _ctrl_state.q[2], _ctrl_state.q[3]);
    math::Matrix<3, 3> R = q_att.to_dcm();

    / all input data is ready, run controller itself /

    / try to move thrust vector shortest way, because yaw response is slower than roll/pitch /
	math::Vector<3> R_z(R(0, 2), R(1, 2), R(2, 2));
	math::Vector<3> R_sp_z(R_sp(0, 2), R_sp(1, 2), R_sp(2, 2));

    / axis and sin(angle) of desired rotation /
	math::Vector<3> e_R = R.transposed() * (R_z % R_sp_z);

    / calculate angle error /
	float e_R_z_sin = e_R.length();
	float e_R_z_cos = R_z * R_sp_z;

    / calculate weight for yaw control /
	float yaw_w = R_sp(2, 2) * R_sp(2, 2);

    / calculate rotation matrix after roll/pitch only rotation /
	math::Matrix<3, 3> R_rp;

	if (e_R_z_sin > 0.0f) {
        / get axis-angle representation /
		float e_R_z_angle = atan2f(e_R_z_sin, e_R_z_cos);
		math::Vector<3> e_R_z_axis = e_R / e_R_z_sin;

		e_R = e_R_z_axis * e_R_z_angle;

        / cross product matrix for e_R_axis /
		math::Matrix<3, 3> e_R_cp;
		e_R_cp.zero();
		e_R_cp(0, 1) = -e_R_z_axis(2);
		e_R_cp(0, 2) = e_R_z_axis(1);
		e_R_cp(1, 0) = e_R_z_axis(2);
		e_R_cp(1, 2) = -e_R_z_axis(0);
		e_R_cp(2, 0) = -e_R_z_axis(1);
		e_R_cp(2, 1) = e_R_z_axis(0);

        / rotation matrix for roll/pitch only rotation /
		R_rp = R * (_I + e_R_cp * e_R_z_sin + e_R_cp * e_R_cp * (1.0f - e_R_z_cos));

	} else {
        / zero roll/pitch rotation /
		R_rp = R;
	}

    / R_rp and R_sp has the same Z axis, calculate yaw error /
	math::Vector<3> R_sp_x(R_sp(0, 0), R_sp(1, 0), R_sp(2, 0));
	math::Vector<3> R_rp_x(R_rp(0, 0), R_rp(1, 0), R_rp(2, 0));
	e_R(2) = atan2f((R_rp_x % R_sp_x) * R_sp_z, R_rp_x * R_sp_x) * yaw_w;

	if (e_R_z_cos < 0.0f) {
        / for large thrust vector rotations use another rotation method:
          calculate angle and axis for R -> R_sp rotation directly /
		math::Quaternion q_error;
		q_error.from_dcm(R.transposed() * R_sp);
		math::Vector<3> e_R_d = q_error(0) >= 0.0f ? q_error.imag()  * 2.0f : -q_error.imag() * 2.0f;

        / use fusion of Z axis based rotation and direct rotation /
		float direct_w = e_R_z_cos * e_R_z_cos * yaw_w;
		e_R = e_R * (1.0f - direct_w) + e_R_d * direct_w;
	}

    / calculate angular rates setpoint /
	_rates_sp = _params.att_p.emult(e_R);

    / limit rates /
	for (int i = 0; i < 3; i++) {
		if ((_v_control_mode.flag_control_velocity_enabled || _v_control_mode.flag_control_auto_enabled) &&
		    !_v_control_mode.flag_control_manual_enabled) {
			_rates_sp(i) = math::constrain(_rates_sp(i), -_params.auto_rate_max(i), _params.auto_rate_max(i));

		} else {
			_rates_sp(i) = math::constrain(_rates_sp(i), -_params.mc_rate_max(i), _params.mc_rate_max(i));
		}
	}

	/ feed forward yaw setpoint rate /
	_rates_sp(2) += _v_att_sp.yaw_sp_move_rate * yaw_w * _params.yaw_ff;

    / weather-vane mode, dampen yaw rate /
	if ((_v_control_mode.flag_control_velocity_enabled || _v_control_mode.flag_control_auto_enabled) &&
	    _v_att_sp.disable_mc_yaw_control == true && !_v_control_mode.flag_control_manual_enabled) {
		float wv_yaw_rate_max = _params.auto_rate_max(2) * _params.vtol_wv_yaw_rate_scale;
		_rates_sp(2) = math::constrain(_rates_sp(2), -wv_yaw_rate_max, wv_yaw_rate_max);
		// prevent integrator winding up in weathervane mode
		_rates_int(2) = 0.0f;
    }
*/
    //create quaternion setpoint
    math::Quaternion q_sp(_v_att_sp.q_d[0], _v_att_sp.q_d[1], _v_att_sp.q_d[2], _v_att_sp.q_d[3]);

    //get current quaternion
    math::Quaternion q_att(_ctrl_state.q[0], _ctrl_state.q[1], _ctrl_state.q[2], _ctrl_state.q[3]);

    //calculate quaternion error
    math::Quaternion q_error;
    q_error=q_sp.conjugated()*q_att;
    q_error.normalize();

    //calculate quaternion error vector
    math::Vector<3> att_err(q_error(1),q_error(2),q_error(3));

    //avoid unwinding
    if (q_error(0)<0.0f)
    {
        att_err*=-1.0f;
    }

    //calculate rates setpoint (PID)
    _rates_sp = _params.att_p.emult(att_err) +
               _att_int +
               _params.att_d.emult(att_err - _att_err_prev) / dt;

    _att_err_prev = att_err;

		/* update integral only if not saturated on low limit and if motor commands are not saturated */
		if (_thrust_sp > MIN_TAKEOFF_THRUST && !_motor_limits.lower_limit && !_motor_limits.upper_limit) {
			for (int i = AXIS_INDEX_ROLL; i < AXIS_COUNT; i++) {
				if (fabsf(_att_control(i)) < _thrust_sp) {
					float rate_i = _rates_int(i) + _params.rate_i(i) * att_err(i) * dt;

					if (PX4_ISFINITE(rate_i) && rate_i > -RATES_I_LIMIT && rate_i < RATES_I_LIMIT &&
					_att_control(i) > -RATES_I_LIMIT && _att_control(i) < RATES_I_LIMIT &&
					/* if the axis is the yaw axis, do not update the integral if the limit is hit */
					!((i == AXIS_INDEX_YAW) && _motor_limits.yaw)) {
						_att_int(i) = rate_i;
					}
				}
			}
		}

    /* explicitly limit the integrator state */
    for (int i = AXIS_INDEX_ROLL; i < AXIS_COUNT; i++) {
        _att_int(i) = math::constrain(_att_int(i), -_params.att_int_lim(i), _params.att_int_lim(i));

    }


}

/*
 * Attitude rates controller.
 * Input: '_rates_sp' vector, '_thrust_sp'
 * Output: '_att_control' vector
 */
void
MulticopterAttitudeControl::control_attitude_rates(float dt)
{
	/* reset integral if disarmed */
	if (!_armed.armed || !_vehicle_status.is_rotary_wing) {
		_rates_int.zero();
	}

	/* current body angular rates */
	math::Vector<3> rates;
	rates(0) = _ctrl_state.roll_rate;
	rates(1) = _ctrl_state.pitch_rate;
	rates(2) = _ctrl_state.yaw_rate;

	/* throttle pid attenuation factor */
	float tpa =  fmaxf(0.0f, fminf(1.0f, 1.0f - _params.tpa_slope * (fabsf(_v_rates_sp.thrust) - _params.tpa_breakpoint)));

	/* angular rates error */
	math::Vector<3> rates_err = _rates_sp - rates;

	_att_control = _params.rate_p.emult(rates_err * tpa) + _params.rate_d.emult(_rates_prev - rates) / dt + _rates_int +
		       _params.rate_ff.emult(_rates_sp);

	_rates_sp_prev = _rates_sp;
	_rates_prev = rates;

	/* update integral only if not saturated on low limit and if motor commands are not saturated */
	if (_thrust_sp > MIN_TAKEOFF_THRUST && !_motor_limits.lower_limit && !_motor_limits.upper_limit) {
		for (int i = AXIS_INDEX_ROLL; i < AXIS_COUNT; i++) {
			if (fabsf(_att_control(i)) < _thrust_sp) {
				float rate_i = _rates_int(i) + _params.rate_i(i) * rates_err(i) * dt;

				if (PX4_ISFINITE(rate_i) && rate_i > -RATES_I_LIMIT && rate_i < RATES_I_LIMIT &&
				    _att_control(i) > -RATES_I_LIMIT && _att_control(i) < RATES_I_LIMIT &&
				    /* if the axis is the yaw axis, do not update the integral if the limit is hit */
				    !((i == AXIS_INDEX_YAW) && _motor_limits.yaw)) {
					_rates_int(i) = rate_i;
				}
			}
		}
	}
}
float MulticopterAttitudeControl::value_lookup(unsigned index_phi, unsigned index_theta, unsigned iterator)
{
    float result=0.0f;
    switch(iterator)
    {
        case 0: result = alpha_lookup1[index_phi][index_theta];
        case 1: result = alpha_lookup2[index_phi][index_theta];
        case 2: result = alpha_lookup3[index_phi][index_theta];
        case 3: result = alpha_lookup4[index_phi][index_theta];
        case 4: result = alpha_lookup5[index_phi][index_theta];
        case 5: result = alpha_lookup6[index_phi][index_theta];
    }
    return result;
}

void MulticopterAttitudeControl::lookup(float theta, float phi, math::Vector<6> (&a))
{
    unsigned theta_index=0;
    unsigned phi_index=0;

    /*Get the indices of the neighbouring values*/
    for(int i=0; i<sizeof(theta_range)/sizeof(theta_range[0]);i++)
    {
        if (theta_range[i]>=theta)
        {
            theta_index=i-1;
            break;
        }
    }
    for(int i=0; i<sizeof(phi_range)/sizeof(phi_range[0]);i++)
    {
        if (phi_range[i]>=phi)
        {
            phi_index=i-1;
            break;
        }
    }

    /*Get the interpolation weights*/
    float phi_i=(phi-phi_range[phi_index])/(phi_range[phi_index+1]-phi_range[phi_index]);
    float theta_i=(theta-theta_range[theta_index])/(theta_range[theta_index+1]-theta_range[theta_index]);

    /*Interpolate 2D*/
    for(int i=0;i<6;i++)
    {
        a(i)=(1-phi_i)*(1-theta_i)*value_lookup(phi_index,theta_index,i)
                + (phi_i)*(1-theta_i)*value_lookup(phi_index+1,theta_index,i)
                + (1-phi_i)*(theta_i)*value_lookup(phi_index,theta_index+1,i)
                + (phi_i)*(theta_i)*value_lookup(phi_index+1,theta_index+1,i);
    }

}



void MulticopterAttitudeControl::alpha (float dt)
 {

    //calculate spherical coordinates from the thrust vector
    float phi = atan2(_vol_thrust_sp.f[1],_vol_thrust_sp.f[0]);
    float theta = atan2(_vol_thrust_sp.f[2],_vol_thrust_sp.f[1]*_vol_thrust_sp.f[1]+_vol_thrust_sp.f[0]*_vol_thrust_sp.f[0]);

    //get lookup values of alpha
    lookup(theta,phi,_alpha_des);

    //alpha infinity


    for (int i=0;i<6;i++)
    {
        float a=fmod((_alpha_prev(i)+(float)M_PI),2*(float)M_PI);

        int k=(_alpha_prev(i)-a+(float)M_PI)/(2*(float)M_PI); //calculate number of rotation

        _alpha_prev(i)=_alpha_prev(i)-k*2*(float)M_PI;

        if (_alpha_des(i)*_alpha_prev(i)<0 && abs(_alpha_des(i)-_alpha_prev(i))>(double)M_PI)
				{
					if (_alpha_prev(i)<_alpha_des(i))
					{_alpha_des(i)=_alpha_des(i)-2*(float)M_PI;
					}
					else
					{_alpha_des(i)=_alpha_des(i)+2*(float)M_PI;}
				}
				else
				{
					_alpha_des(i)=_alpha_des(i);
				}

    _alpha_des(i)=_alpha_des(i)+k*2*(float)M_PI;
    _alpha_prev(i)=_alpha_des(i);

    }

    for (int i=0;i<6;i++)
    {
          if(fabsf(_alpha_des(i)-_alpha_sim_prev(i))>_params.tau_servo*dt)
          {
                _alpha_sim(i)=(_alpha_des(i)-_alpha_sim_prev(i))/fabsf((_alpha_des(i)-_alpha_sim_prev(i)))
                        *_params.tau_servo*dt + _alpha_sim_prev(i);
          }
          else { _alpha_sim(i)=_alpha_des(i);}

  _alpha_sim_prev(i)=_alpha_sim(i);}

}




void
MulticopterAttitudeControl::control_allocation(float dt)
{
    float k=_params.torque_coeff;
    float l=_params.length_axis;

    math::Vector<6> u{_vol_thrust_sp.f,_vol_att_sp};

  float alloc [6][6]= {{-sinf(_alpha_sim(0)),                          sinf(_alpha_sim(1)),                          0.5f*sinf(_alpha_sim(2)),                                               -0.5f*sinf(_alpha_sim(3)),                                               -0.5f*sinf(_alpha_sim(4)),                                               0.5f*sinf(_alpha_sim(5))},
                         {0.0f,                                         0.0f,                                        sqrtf(3)*0.5f*sinf(_alpha_sim(2)),                                      -sqrtf(3)*0.5f*sinf(_alpha_sim(3)),                                      sqrtf(3)*0.5f*sinf(_alpha_sim(4)),                                       -sqrtf(3)*0.5f*sinf(_alpha_sim(5))},
                         {-cosf(_alpha_sim(0)),                          -cosf(_alpha_sim(1)),                         -cosf(_alpha_sim(2)),                                                   -cosf(_alpha_sim(3)),                                                    -cosf(_alpha_sim(4)),                                                    -cosf(_alpha_sim(5))},
                         {-l*cosf(_alpha_sim(0))-k*sinf(_alpha_sim(0)),   l*cosf(_alpha_sim(1))-k*sinf(_alpha_sim(1)),   l*0.5f*cosf(_alpha_sim(2))+k*0.5f*sinf(_alpha_sim(2)),                   -l*0.5f*cosf(_alpha_sim(3))+k*0.5f*sinf(_alpha_sim(3)),                   -l*0.5f*cosf(_alpha_sim(4))+k*0.5f*sinf(_alpha_sim(4)),                   l*0.5f*cosf(_alpha_sim(5))+k*0.5f*sinf(_alpha_sim(5))},
                         {0.0f,                                         0.0f,                                        sqrtf(3)*0.5f*l*cosf(_alpha_sim(2))+sqrtf(3)*0.5f*k*sinf(_alpha_sim(2)), -l*sqrtf(3)*0.5f*cosf(_alpha_sim(3))+k*sqrtf(3)*0.5f*sinf(_alpha_sim(3)), sqrtf(3)*0.5f*l*cosf(_alpha_sim(4))-sqrtf(3)*0.5f*k*sinf(_alpha_sim(4)),  -sqrtf(3)*0.5f*l*cosf(_alpha_sim(5))-sqrtf(3)*0.5f*k*sinf(_alpha_sim(5))},
                         {l*sinf(_alpha_sim(0))-k*cosf(_alpha_sim(0)),    l*sinf(_alpha_sim(1))+k*cosf(_alpha_sim(2)),   l*sinf(_alpha_sim(2))-k*cosf(_alpha_sim(2)),                             l*sinf(_alpha_sim(3))+k*cosf(_alpha_sim(3)),                              l*sinf(_alpha_sim(4))+k*cosf(_alpha_sim(4)),                              l*sinf(_alpha_sim(5))-k*cosf(_alpha_sim(5))}};

    math::Matrix<6,6> A(alloc);
    _omega_des=A.inversed()*u;

}


void
MulticopterAttitudeControl::task_main_trampoline(int argc, char *argv[])
{
	mc_att_control::g_control->task_main();
}

void
MulticopterAttitudeControl::task_main()
{

	/*
	 * do subscriptions
	 */
	_v_att_sp_sub = orb_subscribe(ORB_ID(vehicle_attitude_setpoint));
	_v_rates_sp_sub = orb_subscribe(ORB_ID(vehicle_rates_setpoint));
	_ctrl_state_sub = orb_subscribe(ORB_ID(control_state));
	_v_control_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));
	_params_sub = orb_subscribe(ORB_ID(parameter_update));
	_manual_control_sp_sub = orb_subscribe(ORB_ID(manual_control_setpoint));
	_armed_sub = orb_subscribe(ORB_ID(actuator_armed));
	_vehicle_status_sub = orb_subscribe(ORB_ID(vehicle_status));
	_motor_limits_sub = orb_subscribe(ORB_ID(multirotor_motor_limits));
	_battery_status_sub = orb_subscribe(ORB_ID(battery_status));

	/* initialize parameters cache */
	parameters_update();

	/* wakeup source: vehicle attitude */
	px4_pollfd_struct_t fds[1];

	fds[0].fd = _ctrl_state_sub;
	fds[0].events = POLLIN;

	while (!_task_should_exit) {

		/* wait for up to 100ms for data */
		int pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 100);

		/* timed out - periodic check for _task_should_exit */
		if (pret == 0) {
			continue;
		}

		/* this is undesirable but not much we can do - might want to flag unhappy status */
		if (pret < 0) {
			warn("mc att ctrl: poll error %d, %d", pret, errno);
			/* sleep a bit before next try */
			usleep(100000);
			continue;
		}

		perf_begin(_loop_perf);

		/* run controller on attitude changes */
		if (fds[0].revents & POLLIN) {
			static uint64_t last_run = 0;
			float dt = (hrt_absolute_time() - last_run) / 1000000.0f;
			last_run = hrt_absolute_time();

			/* guard against too small (< 2ms) and too large (> 20ms) dt's */
			if (dt < 0.002f) {
				dt = 0.002f;

			} else if (dt > 0.02f) {
				dt = 0.02f;
			}

			/* copy attitude and control state topics */
			orb_copy(ORB_ID(control_state), _ctrl_state_sub, &_ctrl_state);

			/* check for updates in other topics */
			parameter_update_poll();
			vehicle_control_mode_poll();
			arming_status_poll();
			vehicle_manual_poll();
			vehicle_status_poll();
			vehicle_motor_limits_poll();
			battery_status_poll();

			/* Check if we are in rattitude mode and the pilot is above the threshold on pitch
			 * or roll (yaw can rotate 360 in normal att control).  If both are true don't
			 * even bother running the attitude controllers */
			if (_v_control_mode.flag_control_rattitude_enabled) {
				if (fabsf(_manual_control_sp.y) > _params.rattitude_thres ||
				    fabsf(_manual_control_sp.x) > _params.rattitude_thres) {
					_v_control_mode.flag_control_attitude_enabled = false;
				}
			}

			if (_v_control_mode.flag_control_attitude_enabled) {

				if (_ts_opt_recovery == nullptr) {
					// the  tailsitter recovery instance has not been created, thus, the vehicle
					// is not a tailsitter, do normal attitude control
					control_attitude(dt);

				} else {
					vehicle_attitude_setpoint_poll();
					_thrust_sp = _v_att_sp.thrust;
					math::Quaternion q(_ctrl_state.q[0], _ctrl_state.q[1], _ctrl_state.q[2], _ctrl_state.q[3]);
					math::Quaternion q_sp(&_v_att_sp.q_d[0]);
					_ts_opt_recovery->setAttGains(_params.att_p, _params.yaw_ff);
					_ts_opt_recovery->calcOptimalRates(q, q_sp, _v_att_sp.yaw_sp_move_rate, _rates_sp);

					/* limit rates */
					for (int i = 0; i < 3; i++) {
						_rates_sp(i) = math::constrain(_rates_sp(i), -_params.mc_rate_max(i), _params.mc_rate_max(i));
					}
				}

				/* publish attitude rates setpoint */
				_v_rates_sp.roll = _rates_sp(0);
				_v_rates_sp.pitch = _rates_sp(1);
				_v_rates_sp.yaw = _rates_sp(2);
				_v_rates_sp.thrust = _thrust_sp;
				_v_rates_sp.timestamp = hrt_absolute_time();

				if (_v_rates_sp_pub != nullptr) {
					orb_publish(_rates_sp_id, _v_rates_sp_pub, &_v_rates_sp);

				} else if (_rates_sp_id) {
					_v_rates_sp_pub = orb_advertise(_rates_sp_id, &_v_rates_sp);
				}

				//}

			} else {
				/* attitude controller disabled, poll rates setpoint topic */
				if (_v_control_mode.flag_control_manual_enabled) {
					/* manual rates control - ACRO mode */
					_rates_sp = math::Vector<3>(_manual_control_sp.y, -_manual_control_sp.x,
								    _manual_control_sp.r).emult(_params.acro_rate_max);
					_thrust_sp = math::min(_manual_control_sp.z, MANUAL_THROTTLE_MAX_MULTICOPTER);

					/* publish attitude rates setpoint */
					_v_rates_sp.roll = _rates_sp(0);
					_v_rates_sp.pitch = _rates_sp(1);
					_v_rates_sp.yaw = _rates_sp(2);
					_v_rates_sp.thrust = _thrust_sp;
					_v_rates_sp.timestamp = hrt_absolute_time();

					if (_v_rates_sp_pub != nullptr) {
						orb_publish(_rates_sp_id, _v_rates_sp_pub, &_v_rates_sp);

					} else if (_rates_sp_id) {
						_v_rates_sp_pub = orb_advertise(_rates_sp_id, &_v_rates_sp);
					}

				} else {
					/* attitude controller disabled, poll rates setpoint topic */
					vehicle_rates_setpoint_poll();
					_rates_sp(0) = _v_rates_sp.roll;
					_rates_sp(1) = _v_rates_sp.pitch;
					_rates_sp(2) = _v_rates_sp.yaw;
					_thrust_sp = _v_rates_sp.thrust;
				}
			}

			if (_v_control_mode.flag_control_rates_enabled) {
				control_attitude_rates(dt);
                alpha(dt);
                control_allocation(dt);



                //publish omegas, by voliro, omega equals thrust in kg

                _actuators.control[0] = (PX4_ISFINITE(_omega_des(0))) ? _omega_des(0) : 0.0f;
                _actuators.control[1] = (PX4_ISFINITE(_omega_des(1))) ? _omega_des(1) : 0.0f;
                _actuators.control[2] = (PX4_ISFINITE(_omega_des(2))) ? _omega_des(2) : 0.0f;
                _actuators.control[3] = (PX4_ISFINITE(_omega_des(3))) ? _omega_des(3) : 0.0f;
                _actuators.control[4] = (PX4_ISFINITE(_omega_des(4))) ? _omega_des(4) : 0.0f;
                _actuators.control[5] = (PX4_ISFINITE(_omega_des(5))) ? _omega_des(5) : 0.0f;


               //maps alpha_des from -1 to 1
                for(int i=0;i<6; i++)
               {
                    _alpha_des(i)=_alpha_des(i)/(2*(float)M_PI);
                   }

                //publish alphas

                _actuators_1.control[0] = (PX4_ISFINITE(_alpha_des(0))) ? _alpha_des(0) : 0.0f;
                _actuators_1.control[1] = (PX4_ISFINITE(_alpha_des(1))) ? _alpha_des(1) : 0.0f;
                _actuators_1.control[2] = (PX4_ISFINITE(_alpha_des(2))) ? _alpha_des(2) : 0.0f;
                _actuators_1.control[3] = (PX4_ISFINITE(_alpha_des(3))) ? _alpha_des(3) : 0.0f;
                _actuators_1.control[4] = (PX4_ISFINITE(_alpha_des(4))) ? _alpha_des(4) : 0.0f;
                _actuators_1.control[5] = (PX4_ISFINITE(_alpha_des(5))) ? _alpha_des(5) : 0.0f;

                /* publish actuator controls */


                _actuators.timestamp = hrt_absolute_time();
                _actuators.timestamp_sample = _ctrl_state.timestamp;

                _actuators_1.timestamp = hrt_absolute_time();
                _actuators_1.timestamp_sample = _ctrl_state.timestamp;

				/* scale effort by battery status */
				if (_params.bat_scale_en && _battery_status.scale > 0.0f) {
                    for (int i = 0; i < 6; i++) {
						_actuators.control[i] *= _battery_status.scale;

					}
				}

				_controller_status.roll_rate_integ = _rates_int(0);
				_controller_status.pitch_rate_integ = _rates_int(1);
				_controller_status.yaw_rate_integ = _rates_int(2);
				_controller_status.timestamp = hrt_absolute_time();
       /* publish omegas */

				if (!_actuators_0_circuit_breaker_enabled) {
					if (_actuators_0_pub != nullptr) {

						orb_publish(_actuators_id, _actuators_0_pub, &_actuators);
						perf_end(_controller_latency_perf);

					} else if (_actuators_id) {
						_actuators_0_pub = orb_advertise(_actuators_id, &_actuators);
					}

				}
                    /* publish alphas, added by voliro */

                if (!_actuators_1_circuit_breaker_enabled) {
                    if (_actuators_1_pub != nullptr) {

                        orb_publish(_actuators_1_id, _actuators_1_pub, &_actuators_1);
                        perf_end(_controller_latency_perf);

                    } else if (_actuators_1_id) {
                        _actuators_1_pub = orb_advertise(_actuators_1_id, &_actuators_1);
                    }

                }



				/* publish controller status */
				if (_controller_status_pub != nullptr) {
					orb_publish(ORB_ID(mc_att_ctrl_status), _controller_status_pub, &_controller_status);

				} else {
					_controller_status_pub = orb_advertise(ORB_ID(mc_att_ctrl_status), &_controller_status);
				}
			}

			if (_v_control_mode.flag_control_termination_enabled) {
				if (!_vehicle_status.is_vtol) {

					_rates_sp.zero();
					_rates_int.zero();
					_thrust_sp = 0.0f;
					_att_control.zero();


					/* publish actuator controls */
					_actuators.control[0] = 0.0f;
					_actuators.control[1] = 0.0f;
					_actuators.control[2] = 0.0f;
                    _actuators.control[3] = 0.0f;
                    _actuators.control[4] = 0.0f;
                    _actuators.control[5] = 0.0f;
					_actuators.timestamp = hrt_absolute_time();
					_actuators.timestamp_sample = _ctrl_state.timestamp;

                    _actuators_1.control[0] = 0.0f;
                    _actuators_1.control[1] = 0.0f;
                    _actuators_1.control[2] = 0.0f;
                    _actuators_1.control[3] = 0.0f;
                    _actuators_1.control[4] = 0.0f;
                    _actuators_1.control[5] = 0.0f;
                    _actuators_1.timestamp = hrt_absolute_time();
                    _actuators_1.timestamp_sample = _ctrl_state.timestamp;

					if (!_actuators_0_circuit_breaker_enabled) {
						if (_actuators_0_pub != nullptr) {

							orb_publish(_actuators_id, _actuators_0_pub, &_actuators);
							perf_end(_controller_latency_perf);

						} else if (_actuators_id) {
							_actuators_0_pub = orb_advertise(_actuators_id, &_actuators);
						}
					}
                    //added by voliro


                    if (!_actuators_1_circuit_breaker_enabled) {
                        if (_actuators_1_pub != nullptr) {

                            orb_publish(_actuators_1_id, _actuators_1_pub, &_actuators_1);
                            perf_end(_controller_latency_perf);

                        } else if (_actuators_1_id) {
                            _actuators_1_pub = orb_advertise(_actuators_1_id, &_actuators_1);
                        }
                    }




                    //
					_controller_status.roll_rate_integ = _rates_int(0);
					_controller_status.pitch_rate_integ = _rates_int(1);
					_controller_status.yaw_rate_integ = _rates_int(2);
					_controller_status.timestamp = hrt_absolute_time();

					/* publish controller status */
					if (_controller_status_pub != nullptr) {
						orb_publish(ORB_ID(mc_att_ctrl_status), _controller_status_pub, &_controller_status);

					} else {
						_controller_status_pub = orb_advertise(ORB_ID(mc_att_ctrl_status), &_controller_status);
					}

					/* publish attitude rates setpoint */
					_v_rates_sp.roll = _rates_sp(0);
					_v_rates_sp.pitch = _rates_sp(1);
					_v_rates_sp.yaw = _rates_sp(2);
					_v_rates_sp.thrust = _thrust_sp;
					_v_rates_sp.timestamp = hrt_absolute_time();

					if (_v_rates_sp_pub != nullptr) {
						orb_publish(_rates_sp_id, _v_rates_sp_pub, &_v_rates_sp);

					} else if (_rates_sp_id) {
						_v_rates_sp_pub = orb_advertise(_rates_sp_id, &_v_rates_sp);
					}
				}
			}
		}

		perf_end(_loop_perf);
	}

	_control_task = -1;
	return;
}

int
MulticopterAttitudeControl::start()
{
	ASSERT(_control_task == -1);

	/* start the task */
	_control_task = px4_task_spawn_cmd("mc_att_control",
					   SCHED_DEFAULT,
					   SCHED_PRIORITY_MAX - 5,
					   1500,
					   (px4_main_t)&MulticopterAttitudeControl::task_main_trampoline,
					   nullptr);

	if (_control_task < 0) {
		warn("task start failed");
		return -errno;
	}

	return OK;
}

int mc_att_control_main(int argc, char *argv[])
{
	if (argc < 2) {
		warnx("usage: mc_att_control {start|stop|status}");
		return 1;
	}

	if (!strcmp(argv[1], "start")) {

		if (mc_att_control::g_control != nullptr) {
			warnx("already running");
			return 1;
		}

		mc_att_control::g_control = new MulticopterAttitudeControl;

		if (mc_att_control::g_control == nullptr) {
			warnx("alloc failed");
			return 1;
		}

		if (OK != mc_att_control::g_control->start()) {
			delete mc_att_control::g_control;
			mc_att_control::g_control = nullptr;
			warnx("start failed");
			return 1;
		}

		return 0;
	}

	if (!strcmp(argv[1], "stop")) {
		if (mc_att_control::g_control == nullptr) {
			warnx("not running");
			return 1;
		}

		delete mc_att_control::g_control;
		mc_att_control::g_control = nullptr;
		return 0;
	}

	if (!strcmp(argv[1], "status")) {
		if (mc_att_control::g_control) {
			warnx("running");
			return 0;

		} else {
			warnx("not running");
			return 1;
		}
	}

	warnx("unrecognized command");
	return 1;
}
