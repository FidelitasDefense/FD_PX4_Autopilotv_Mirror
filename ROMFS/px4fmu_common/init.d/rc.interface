#!nsh
#
# Script to configure control interface
#
#
# NOTE: environment variable references:
#  If the dollar sign ('$') is followed by a left bracket ('{') then the
#  variable name is terminated with the right bracket character ('}').
#  Otherwise, the variable name goes to the end of the argument.
#

echo "Executing rc.interface"

#
# Declare local script variables and initialize default values
#
set AUX_MODE                            pwm
set FAILSAFE                            none
set FAILSAFE_AUX                        none
set FMU_ARGS                            ""
set FMU_MODE                            pwm
set IO_FILE                             /etc/extras/
set IO_PRESENT                          no
set MKBLCTRL_ARGS                       ""
set SDCARD_MIXERS_PATH                  /fs/microsd/etc/mixers
set USE_IO                              no

#
# Set script parameters for board specific configurations here
#
if ver hwcmp AEROFC_V1 CRAZYFLIE MINDPX_V2 NXPHLITE_V3 PX4FMU_V4
then
	set MIXER_AUX none
fi

#
# If mount (gimbal) control is enabled and output mode is AUX, set the aux
# mixer to mount (override the airframe-specific MIXER_AUX setting)
#
if param compare MNT_MODE_IN -1
then
else
	if param compare MNT_MODE_OUT 0
	then
		set MIXER_AUX mount
	fi
fi

# Sensors on the PWM interface bank
if param compare SENS_EN_LL40LS 1
then
	# clear pins 5 and 6
	set FMU_MODE pwm4
	set AUX_MODE pwm4
fi

if param greater TRIG_MODE 0
then
	# We ONLY support trigger on pins 5 and 6 when simultanously using AUX for actuator output
	if param compare TRIG_PINS 56
	then
		# clear pins 5 and 6
		set FMU_MODE pwm4
		set AUX_MODE pwm4
	else
		set FMU_MODE none
		set AUX_MODE none
	fi
fi
#
# Set the FMU to run as a task for low latency instead of in the work queue at fixed rate
#
if param compare SYS_FMU_TASK 1
then
	set FMU_ARGS "-t"
fi

#
# Check if HITL is enabled.
#
if param compare SYS_HITL 1
then
	set OUTPUT_MODE hil
fi

#
# Check if UAVCAN is enabled, default to it for ESCs
#
if param greater UAVCAN_ENABLE 2
then
	set OUTPUT_MODE uavcan_esc
fi

#
# Set USE_IO flag
#
if param compare SYS_USE_IO 1
then
	set USE_IO yes
fi

if [ $USE_IO == yes ]
then
	#
	# Check if PX4IO present and update firmware if needed
	#
	if [ -f /etc/extras/px4io-v2.bin ]
	then
		set IO_FILE /etc/extras/px4io-v2.bin

		if px4io checkcrc ${IO_FILE}
		then
			set IO_PRESENT yes
		else
			tune_control play -m "MLL32CP8MB"

			if px4io start
			then
				# try to safe px4 io so motor outputs dont go crazy
				if px4io safety_on
				then
					# success! no-op
				else
					# px4io did not respond to the safety command
					px4io stop
				fi
			fi

			if px4io forceupdate 14662 ${IO_FILE}
			then
				usleep 10000
				if px4io checkcrc ${IO_FILE}
				then
					echo "PX4IO CRC OK after updating" >> $LOG_FILE
					tune_control play -m "MLL8CDE"

					set IO_PRESENT yes
				else
					echo "PX4IO update failed" >> $LOG_FILE
					tune_control play -t 2
				fi
			else
				echo "PX4IO update failed" >> $LOG_FILE
				tune_control play -t 2
			fi
		fi
	fi

	if [ $IO_PRESENT == no ]
	then
		echo "PX4IO not found" >> $LOG_FILE
		tune_control play -t 2
	fi
fi

#
# Set default output mode if not set
#
if [ $OUTPUT_MODE == none ]
then
	if [ $USE_IO == yes ]
	then
		if [ $IO_PRESENT == yes ]
		then
			set OUTPUT_MODE io
		else
			# If we weed IO for output but none is present, disable output
			set OUTPUT_MODE none
		fi
	else
		set OUTPUT_MODE fmu
	fi
fi

# If OUTPUT_MODE == none then something is wrong with setup and we shouldn't try to enable output
if [ $OUTPUT_MODE != none ]
then
	if [ $OUTPUT_MODE == fmu ]
	then
		if fmu mode_$FMU_MODE $FMU_ARGS
		then
		else
			echo "FMU start failed" >> $LOG_FILE
			tune_control play -t 2
		fi
	fi

	if [ $OUTPUT_MODE == hil ]
	then
		if pwm_out_sim start
		then
		else
			tune_control play -t 2
		fi
	fi
	
	if [ $OUTPUT_MODE == mkblctrl ]
	then
		if [ $MKBLCTRL_MODE == x ]
		then
			set MKBLCTRL_ARGS "-mkmode x"
		fi

		if [ $MKBLCTRL_MODE == + ]
		then
			set MKBLCTRL_ARGS "-mkmode +"
		fi

		if mkblctrl $MKBLCTRL_ARGS
		then
		else
			tune_control play -t 2
		fi
	fi

	if [ $OUTPUT_MODE == tap_esc ]
	then
		set FMU_MODE rcin
	fi

	if [ $OUTPUT_MODE == uavcan_esc ]
	then
		if param compare UAVCAN_ENABLE 0
		then
			param set UAVCAN_ENABLE 3
		fi
	fi

	if [ $OUTPUT_MODE == io -o $OUTPUT_MODE == uavcan_esc ]
	then
		if px4io start
		then
			sh /etc/init.d/rc.io
		else
			echo "PX4IO start failed" >> $LOG_FILE
			tune_control play -t 2
		fi
	fi

	#
	# Start IO or FMU for RC PPM input if needed
	#
	if [ $OUTPUT_MODE != io -a $IO_PRESENT == yes ]
	then
		if px4io start
		then
			sh /etc/init.d/rc.io
		else
			echo "PX4IO start failed" >> $LOG_FILE
			tune_control play -t 2
		fi
	fi
	else
		if [ $OUTPUT_MODE != fmu ]
		then
			if fmu mode_${FMU_MODE} $FMU_ARGS
			then
			else
				echo "FMU mode_${FMU_MODE} start failed" >> $LOG_FILE
				tune_control play -t 2
			fi
		fi
	fi
fi

if [ $MIXER != none -a $MIXER != skip ]
then
	#
	# Load main mixer
	#
	if [ $MIXER_AUX == none -a $USE_IO == yes ]
	then
		set MIXER_AUX ${MIXER}
	fi

	# Use the mixer file from the SD-card if it exists
	if [ -f ${SDCARD_MIXERS_PATH}/${MIXER}.main.mix ]
	then
		set MIXER_FILE ${SDCARD_MIXERS_PATH}/${MIXER}.main.mix
	# Try out the old convention, for backward compatibility
	else

		if [ -f ${SDCARD_MIXERS_PATH}/${MIXER}.mix ]
		then
			set MIXER_FILE ${SDCARD_MIXERS_PATH}/${MIXER}.mix
		else
			set MIXER_FILE /etc/mixers/${MIXER}.main.mix
		fi
	fi

	if [ $OUTPUT_MODE == mkblctrl ]
	then
		set OUTPUT_DEV /dev/mkblctrl0
	else
		set OUTPUT_DEV /dev/pwm_output0
	fi

	if [ $OUTPUT_MODE == uavcan_esc ]
	then
		set OUTPUT_DEV /dev/uavcan/esc
	fi

	if [ $OUTPUT_MODE == tap_esc ]
	then
		set OUTPUT_DEV /dev/tap_esc
	fi

	if mixer load ${OUTPUT_DEV} ${MIXER_FILE}
	then
		echo "INFO  [init] Mixer: ${MIXER_FILE} on ${OUTPUT_DEV}"
	else
		echo "ERROR  [init] Failed loading mixer: ${MIXER_FILE}"
		echo "ERROR  [init] Failed loading mixer: ${MIXER_FILE}" >> $LOG_FILE
		tune_control play -t 2
	fi
else
	if [ $MIXER != skip ]
	then
		echo "ERROR  [init] Mixer undefined"
		echo "ERROR  [init] Mixer undefined" >> $LOG_FILE
		tune_control play -t 2
	fi
fi

#
# Setup PWM output signals.
#
if [ $OUTPUT_MODE == fmu -o $OUTPUT_MODE == io ]
then
	if [ $PWM_OUT != none ]
	then
		#
		# Set PWM output frequency
		#
		if [ $PWM_RATE != none ]
		then
			pwm rate -c ${PWM_OUT} -r ${PWM_RATE}
		fi

		#
		# Set disarmed, min and max PWM values
		#
		if [ $PWM_DISARMED != none ]
		then
			pwm disarmed -c ${PWM_OUT} -p ${PWM_DISARMED}
		fi
		if [ $PWM_MIN != none ]
		then
			pwm min -c ${PWM_OUT} -p ${PWM_MIN}
		fi
		if [ $PWM_MAX != none ]
		then
			pwm max -c ${PWM_OUT} -p ${PWM_MAX}
		fi
	fi

	#
	# Per channel disarmed settings
	#
	pwm disarmed -c 1 -p p:PWM_MAIN_DIS1
	pwm disarmed -c 2 -p p:PWM_MAIN_DIS2
	pwm disarmed -c 3 -p p:PWM_MAIN_DIS3
	pwm disarmed -c 4 -p p:PWM_MAIN_DIS4
	pwm disarmed -c 5 -p p:PWM_MAIN_DIS5
	pwm disarmed -c 6 -p p:PWM_MAIN_DIS6
	pwm disarmed -c 7 -p p:PWM_MAIN_DIS7
	pwm disarmed -c 8 -p p:PWM_MAIN_DIS8

	if [ $FAILSAFE != none ]
	then
		pwm failsafe -d ${OUTPUT_DEV} ${FAILSAFE}
	fi
fi

if [ $MIXER_AUX != none -a $AUX_MODE != none ]
then
	#
	# Load aux mixer
	#
	set MIXER_AUX_FILE none
	set OUTPUT_AUX_DEV /dev/pwm_output1

	if [ -f ${SDCARD_MIXERS_PATH}/${MIXER_AUX}.aux.mix ]
	then
		set MIXER_AUX_FILE ${SDCARD_MIXERS_PATH}/${MIXER_AUX}.aux.mix
	else

		if [ -f /etc/mixers/${MIXER_AUX}.aux.mix ]
		then
			set MIXER_AUX_FILE /etc/mixers/${MIXER_AUX}.aux.mix
		fi
	fi

	if [ $MIXER_AUX_FILE != none ]
	then
		if fmu mode_${AUX_MODE} $FMU_ARGS
		then
			# Append aux mixer to main device
			if param compare SYS_HITL 1
			then
				if mixer append ${OUTPUT_DEV} ${MIXER_AUX_FILE}
				then
					echo "INFO  [init] Mixer: ${MIXER_AUX_FILE} appended to ${OUTPUT_DEV}"
				else
					echo "ERROR  [init] Failed appending mixer: ${MIXER_AUX_FILE}"
					echo "ERROR  [init] Failed appending mixer: ${MIXER_AUX_FILE}" >> $LOG_FILE
				fi
			fi
			if [ -e $OUTPUT_AUX_DEV -a $OUTPUT_MODE != hil ]
			then
				if mixer load ${OUTPUT_AUX_DEV} ${MIXER_AUX_FILE}
				then
					echo "INFO  [init] Mixer: ${MIXER_AUX_FILE} on ${OUTPUT_AUX_DEV}"
				else
					echo "ERROR  [init] Failed loading mixer: ${MIXER_AUX_FILE}"
					echo "ERROR  [init] Failed loading mixer: ${MIXER_AUX_FILE}" >> $LOG_FILE
				fi
			else
				set PWM_AUX_OUT none
				set FAILSAFE_AUX none
			fi
		else
			echo "ERROR: Could not start: fmu mode_pwm" >> $LOG_FILE
			tune_control play -t 2
			set PWM_AUX_OUT none
			set FAILSAFE_AUX none
		fi

		# Set min / max for aux out and rates
		if [ $PWM_AUX_OUT != none ]
		then
			#
			# Set PWM_AUX output frequency
			#
			if [ $PWM_AUX_RATE != none ]
			then
				pwm rate -c ${PWM_AUX_OUT} -r ${PWM_AUX_RATE} -d ${OUTPUT_AUX_DEV}
			fi

			if [ $PWM_AUX_MIN != none ]
			then
				pwm min -c ${PWM_AUX_OUT} -p ${PWM_AUX_MIN} -d ${OUTPUT_AUX_DEV}
			fi
			if [ $PWM_AUX_MAX != none ]
			then
				pwm max -c ${PWM_AUX_OUT} -p ${PWM_AUX_MAX} -d ${OUTPUT_AUX_DEV}
			fi
		fi

		# Set disarmed values for aux out

		# Transitional support until all configs
		# are updated
		if [ $PWM_ACHDIS == none ]
		then
			set PWM_ACHDIS ${PWM_AUX_OUT}
		fi

		#
		# Set disarmed, min and max PWM_AUX values
		#
		if [ $PWM_AUX_DISARMED != none -a $PWM_ACHDIS != none ]
		then
			pwm disarmed -c ${PWM_ACHDIS} -p ${PWM_AUX_DISARMED} -d ${OUTPUT_AUX_DEV}
		fi

		#
		# Per channel disarmed settings
		#
		pwm disarmed -c 1 -p p:PWM_AUX_DIS1 -d ${OUTPUT_AUX_DEV}
		pwm disarmed -c 2 -p p:PWM_AUX_DIS2 -d ${OUTPUT_AUX_DEV}
		pwm disarmed -c 3 -p p:PWM_AUX_DIS3 -d ${OUTPUT_AUX_DEV}
		pwm disarmed -c 4 -p p:PWM_AUX_DIS4 -d ${OUTPUT_AUX_DEV}
		pwm disarmed -c 5 -p p:PWM_AUX_DIS5 -d ${OUTPUT_AUX_DEV}
		pwm disarmed -c 6 -p p:PWM_AUX_DIS6 -d ${OUTPUT_AUX_DEV}

		if [ $FAILSAFE_AUX != none ]
		then
			pwm failsafe -d ${OUTPUT_AUX_DEV} ${FAILSAFE}
		fi

	fi
fi

#
# Unset all local script variables to free RAM
#
unset AUX_MODE
unset FAILSAFE
unset FAILSAFE_AUX
unset FMU_ARGS
unset FMU_MODE
unset IO_FILE
unset IO_PRESENT
unset MKBLCTRL_ARGS
unset SDCARD_MIXERS_PATH
unset USE_IO
